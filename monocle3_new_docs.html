---
layout: vanilla
permalink: /monocle3_docs/
description: "Documentation for Monocle."
modified: 2013-09-11
tags: [monocle, manual, vignette]
---
<!DOCTYPE html>
<html lang= "{{ page.lang | default: site.lang | default: "en" }}">

  {% include head.html %}

  <!-- See here for how to use the TOC control:
  https://afeld.github.io/bootstrap-toc/ -->
  <body  data-spy= "scroll" data-target= "#toc">
    {% include header.html %}

<div class= "container">
<div class= "row">
<!-- sidebar, which will move to the top on a small screen -->
<div class= "col-sm-4">
  <nav id= "toc" data-spy= "affix" data-toggle= "toc"></nav>
</div>
<!-- main content area -->
<div class= "col-sm-8">

<h2>Introduction</h2>

<p>Single cell transcriptome sequencing (sc-RNA-seq) experiments allow us to discover new cell types and helps us understand how they arise in development. The <strong>Monocle</strong> package provides a toolkit for analyzing single cell gene expression experiments.</p>

<p>Monocle can help you perform three main types of analysis:
<ul>
<li><strong>Clustering, classifying, and counting cells.</strong> Single-cell RNA-Seq experiments allow you to discover new (and possibly rare) subtypes of cells. Monocle helps you identify them.
<li><strong>Constructing single-cell trajectories.</strong> In development, disease, and throughout life, cells transition from one state to another. Monocle helps you discover these transitions.
<li> <strong>Differential expression analysis.</strong> Characterizing new cell types and states begins with comparing them to other, better understood cells. Monocle includes a sophisticated but easy-to-use system for differential expression.
</ul>


<div class= "panel panel-warning">
<div class= "panel-heading">
<h3 class= "panel-title" data-toc-skip>Under construction</h3>
</div>
<div class= "panel-body">
<p>Monocle 3 is currently in the <a href="https://en.wikipedia.org/wiki/Software_release_life_cycle#Alpha">alpha phase</a> of its development. This means not all planned features have been implemented, the API is not yet finalized, and updates might break prior analyses. We are working hard towards a beta release, but please be patient while Monocle 3 is under construction.</p>

<p>The documentation on this page is also still under construction. Not all features currently implemented have been documented.</p>
</div>
</div>



For more information on the algorithms at the core of
<strong>Monocle</strong>, or to learn more about how to use single cell RNA-Seq
to study complex biological processes, explore <a href= "{{ site.baseurl }}/papers/">our
publications</a>.</p>

Before we look at Monocle's functions for each of these common analysis tasks,
let's see how to install Monocle.


<h2>Installing Monocle 3</h2>

<h3> Required software </h3>

<p>Monocle runs in the <a href= "http://www.r-project.org/">R statistical
computing environment</a>. You will need R version 3.5 or higher, Bioconductor
version 3.5, and monocle 3.0.0 or higher to have access to the latest features.
To install monocle 3 through the cole-trapnell-lab GitHub, execute:

{% highlight R %}
devtools::install_github('cole-trapnell-lab/monocle3')
{% endhighlight %}

<h3> Testing the installation </h3>

<p> To ensure that Monocle was installed correctly, start a new R session and run:
</p>

{% highlight R %}
library(monocle3)
{% endhighlight %}

<h2>Getting Help</h2>

<p>Questions about Monocle should be posted on our <a
href= "https://groups.google.com/forum/#!forum/monocle-users">Google Group</a>.
Please use <a href= "mailto:monocle.users@gmail.com">monocle.users@gmail.com</a>
for private communications that cannot be addressed by the Monocle user
community. Please do not email technical questions to Monocle contributors
directly.</p>

<!-- <h2>Recommended analysis protocol</h2>

<p>Monocle is a powerful toolkit for analyzing single-cell RNA-seq.  You don't need
to use all of its features for every analysis, and there are more than one way
to do some steps. The workflow is broken up into broad steps. When there's more than
one way to do a certain step, we've labeled the options as follows:

<table class= "table">
<tbody>
<tr>
<td><span class= "label label-danger">Required</span></td>
<td>You need to do this.</td>
</tr>
<tr>
<td><span class= "label label-info">Recommended</span> </td>
<td>Of the ways you could do this, we recommend you try this one first.</td>
</tr>
<tr>
<td><span class= "label label-success">Alternative</span></td>
<td>Of the ways you could do this, this way might work better than the one we usually recommend.</td>
</tr>
</tbody>
</table> -->

<h3>Workflow steps at a glance</h3>
<p>Below, you can see snippets of code that highlight the main steps of Monocle.
Click on the section headers to jump to the detailed sections describing each one. </p>

<h4><a href= "{{ site.baseurl }}/docs/#getting-started-with-monocle">Store Data in a <a href = "https://rdrr.io/bioc/monocle/man/cell_data_set.html">cell_data_set</a> Object</a></h4>
The first step in working with Monocle is to load up your data into Monocle's
main class, <code><a href = "https://rdrr.io/bioc/monocle/man/cell_data_set.html">cell_data_set</a></code>:

{% highlight R %}
expression_matrix = readMM(url("http://jpacker-data.s3.amazonaws.com/public/worm/L2/Cao_et_al_2017_data_2019_update.exprs.mm.gz"))
cell_metadata = read.delim(url("http://jpacker-data.s3.amazonaws.com/public/worm/L2/Cao_et_al_2017_data_2019_update.fData.tsv"))
gene_annotation = read.delim(url("http://jpacker-data.s3.amazonaws.com/public/worm/L2/Cao_et_al_2017_data_2019_update.pData.tsv"))
gene_annotation$use_for_ordering = NULL

cds <- new_cell_data_set(expression_matrix,
                cell_metadata = cell_metadata,
                gene_metadata = gene_annotation)
## Step 1: Normalize and pre-process the data
cds <- preprocess_cds(cds, num_dim = 100, residual_model_formula_str = "~ batch")

{% endhighlight %}

<!-- <h4><a href= "{{ site.baseurl }}/docs/#classifying-and-counting-cells">Classify cells with known marker genes</a></h4>
Next, leverage your knowledge of key marker genes to quickly and easily classify your cells by type:
{% highlight R %}
cth <- newCellTypeHierarchy()

MYF5_id <- row.names(subset(fData(cds), gene_short_name == "MYF5"))
ANPEP_id <- row.names(subset(fData(cds), gene_short_name == "ANPEP"))

cth <- addCellType(cth, "Myoblast", classify_func =
function(x) { x[MYF5_id,] >= 1 })
cth <- addCellType(cth, "Fibroblast", classify_func =
function(x) { x[MYF5_id,] < 1 & x[ANPEP_id,] > 1 } )

cds <- classifyCells(cds, cth, 0.1)
{% endhighlight %} -->

<h4><a href= "{{ site.baseurl }}/docs/#clustering-cells">Cluster your cells</a></h4>
You can easily cluster your cells to find new types:

{% highlight R %}
cds = reduce_dimension(cds)
cds = cluster_cells(cds)
{% endhighlight %}

<h4><span class= "label label-info">Optional</span> <a href= "{{ site.baseurl }}/docs/#constructing-single-cell-trajectories">Order cells in pseudotime along a trajectory</a> </h4>
Now, put your cells in order by how much progress they've made through whatever process you're studying, such as differentiation,
reprogramming, or an immune response.

{% highlight R %}
cds = learn_graph(cds)
cds = order_cells(cds)
plot_cells(cds)
{% endhighlight %}

<h4><span class= "label label-info">Optional</span> <a href= "{{ site.baseurl }}/docs/#differential-expression-analysis">Perform differential expression analysis</a> </h4>
Compare groups of cells in myriad ways to find differentially expressed genes,
controlling for batch effects and treatments as you like:

{% highlight R %}
gene_fits = fit_models(cds, model_formula_str = "~embryo.time")
fit_coefs = coefficient_table(gene_fits)
emb_time_terms = fit_coefs %>% filter(term == "embryo.time")
emb_time_terms = emb_time_terms %>% mutate(q_value = p.adjust(p_value))
sig_genes = emb_time_terms %>% filter (q_value < 0.05) %>% pull(gene_short_name)
{% endhighlight %}


<h2>Getting started with monocle </h2>

Monocle takes a matrix of gene expression values as calculated by Cufflinks or another gene expression estimation program. Monocle can work with relative expression values (e.g. FPKM or TPM units) or absolute transcript counts (e.g. from UMI experiments). Monocle also works "out-of-the-box" with the transcript count matrices produced by <a href= "https://support.10xgenomics.com/single-cell/software/overview/welcome">CellRanger</a>, the software pipeline for analyzing experiments from the 10X Genomics Chromium instrument. Monocle also works well with data from other RNA-Seq workflows such as <a href= "http://biorxiv.org/content/early/2017/02/02/104844">sci-RNA-Seq</a> and instruments like the Biorad ddSEQ. Although Monocle can be used with raw read counts, these are not directly proportional to expression values unless you normalize them by length, so some Monocle functions could produce nonsense results. If you don't have UMI counts, We recommend you load up FPKM or TPM values instead of raw read counts.

<h3>The cell_data_set class</h3>

Monocle holds single cell expression data in objects of the <code><a href = "https://rdrr.io/bioc/monocle/man/cell_data_set.html">cell_data_set</a></code> class. The class is derived from the Bioconductor <code>ExpressionSet</code> class, which provides a common interface familiar to those who have analyzed microarray experiments with Bioconductor. The class requires three input files:
<p> </p>
<p>
  <font color="red">
    XX phenoData and featureData need to be updated w/ cell_metadata and gene_metadata XX
  </font>
</p>
<ul>
<li> <code>exprs</code>, a numeric matrix of expression values, where rows are genes, and columns are cells
<li> <code>phenoData</code>, an <code>AnnotatedDataFrame</code> object, where rows are cells, and columns are cell attributes (such as cell type, culture condition, day captured, etc.)
<li> <code>featureData</code>, an <code>AnnotatedDataFrame</code> object, where rows are features (e.g. genes), and columns are gene attributes, such as biotype, gc content, etc.
</ul>
<p>
<div class= "panel panel-warning">
<div class= "panel-heading">

<h3 class= "panel-title" data-toc-skip>Required dimensions for input files</h3>

</div>
<div class= "panel-body">
The expression value matrix <strong>must</strong>:
<ul>
<li>have the same number of columns as the <code>phenoData</code> has rows.
<li>have the same number of rows as the <code>featureData</code> data frame has rows.
</ul>
Additionally:
<ul>
<li>row names of the <code>phenoData</code> object should match the column names of the expression matrix.
<li>row names of the <code>featureData</code> object should match row names of the expression matrix.
<li> one of the columns of the <code>featureData</code> should be named "gene_short_name".
</ul>

</div>
</div>

<p>You can create a new <code><a href = "https://rdrr.io/bioc/monocle/man/cell_data_set.html">cell_data_set</a></code> object as follows:</p>

<p>
{% highlight R %}
#do not run
expression_matrix = readRDS(url("http://jpacker-data.s3.amazonaws.com/for-cole/for-cole.ciliated.amphid.neurons.exprs.rds"))
cell_metadata = readRDS(url("http://jpacker-data.s3.amazonaws.com/for-cole/for-cole.ciliated.amphid.neurons.pData.rds"))
gene_annotation = readRDS(url("http://jpacker-data.s3.amazonaws.com/for-cole/for-cole.ciliated.amphid.neurons.fData.rds"))
gene_annotation$use_for_ordering = NULL
{% endhighlight %}
</p>

<p>Once these tables are loaded, you can create the <a href = "https://rdrr.io/bioc/monocle/man/cell_data_set.html">cell_data_set</a> object like this:</p>

<p>
{% highlight R %}
cds <- new_cell_data_set(expression_matrix,
                                   cell_metadata = cell_metadata,
                                   gene_metadata = gene_annotation)
{% endhighlight %}
</p>

<p>This will create a <a href = "https://rdrr.io/bioc/monocle/man/cell_data_set.html">cell_data_set</a> object with expression values measured in
FPKM, a measure of relative expression reported by Cufflinks. By default,
Monocle assumes that your expression data is in units of transcript counts and
uses a negative binomial model to test for differential expression in downstream
steps. However, if you're using relative expression values such as TPM or FPKM
data, see below for how to tell Monocle how to model it in downstream steps.</p>

<!-- FIXME: UPDATE THE DESCRIPTION BELOW TO REFLECT NEW CENSUS PACKAGE  -->
<!-- <p>
<div class= "panel panel-warning">
<div class= "panel-heading">
<h3 class= "panel-title" data-toc-skip>Don't normalize data yourself</h3>
</div>
<div class= "panel-body">
if you do have UMI data, you should <i>not</i> normalize it yourself prior to creating your <code><a href = "https://rdrr.io/bioc/monocle/man/cell_data_set.html">cell_data_set</a></code>.
You should also <i>not</i> try to convert the UMI counts to relative abundances (by converting it to FPKM/TPM data).
You should <i>not</i> use <code><a href = "https://rdrr.io/bioc/monocle/man/relative2abs.html">relative2abs()</a></code> as discussed below in the section on  <a href = "{{ site.baseurl }}/docs/#converting-tpm-fpkm-values-into-mrna-counts-alternative"> Converting TPM to mRNA Counts</a>. Monocle will do all needed normalization steps internally.
Normalizing it yourself risks breaking some of Monocle's key steps.
</div>
</div>
</p> -->

<!-- FIXME: UPDATE THE DESCRIPTION BELOW WHEN WE HAVE EXPORT IMPORT FUNCTIONS  -->
<!--
<h3>Importing & exporting data with other packages</h3>

<strong>XXX NEED TO UPDATE XXX</strong>

<p> Monocle is able to convert Seurat objects from the package "Seurat" and SCESets from the package
"scater" into cell_data_set objects that Monocle can use.
It's also worth noting that the function will also work with SCESets from "Scran".
To convert from either a Seurat object or a SCESet
to a cell_data_set, execute the function <code>importCDS()</code> as shown:</p>

{% highlight R %}

# Where 'data_to_be_imported' can either be a Seurat object
# or an SCESet.

importCDS(data_to_be_imported)

# We can set the parameter 'import_all' to TRUE if we'd like to
# import all the slots from our Seurat object or SCESet.
# (Default is FALSE or only keep minimal dataset)

importCDS(data_to_be_imported, import_all = TRUE)

{% endhighlight %}

<p> Monocle can also export data from cell_data_sets to the package "Seurat" through the
function <code>exportCDS()</code>:

{% highlight R %}
lung <- load_lung()

# To convert to Seurat object
lung_seurat <- exportCDS(lung, 'Seurat')

{% endhighlight %} -->

<h3 data-toc-text= "Working with large data sets">Working with large data sets</h3>

<p> Some single-cell RNA-Seq experiments report measurements from tens of thousands of cells or more.
As instrumentation improves and costs drop, experiments will become ever larger and more complex, with many conditions, controls, and replicates.
A matrix of expression data with 50,000 cells and a measurement for each of the 25,000+ genes in the human genome can take up a lot of memory.
However, because current protocols typically don't capture all or even most of the mRNA molecules in each cell, many of the entries of expression matrices are zero.
Using <i>sparse matrices</i> can help you work with huge datasets on a typical computer.
We generally recommend the use of sparseMatrices for most users, as it speeds up many computations even for more modestly sized datasets. </p>

<p> To work with your data in a sparse format, simply provide it to Monocle as a sparse matrix from the <code>Matrix</code> package: </p>

<p>
{% highlight R %}
cds <- new_cell_data_set(as(umi_matrix, "sparseMatrix"),
      cell_metadata = cell_metadata,
      gene_metadata = gene_metadata)
{% endhighlight %}
</p>

<p>
<div class= "panel panel-warning">
<div class= "panel-heading">
<h3 class= "panel-title" data-toc-skip>Don't accidentally convert to a dense expression matrix</h3>
</div>
<div class= "panel-body">
The output from a number of RNA-Seq pipelines, including CellRanger, is already in a sparseMatrix format (e.g. MTX).
If so, you should just pass it directly to <a href = "https://rdrr.io/bioc/monocle/man/new_cell_data_set.html">new_cell_data_set</a> without first converting it to a dense matrix (via <code>as.matrix()</code>, because that may exceed your available memeory.
</div>
</div>
</p>

If you have 10X Genomics data and are using <code>cellrangerRkit</code>, you can use it to load your data and then pass that to Monocle as follows:

<p> </p>
<p>
  <font color="red">
    XX are pData and fData still functions of cell_data_set? XX
  </font>
</p>

{% highlight R %}
# Use tenx_to_cds here when it is ready

cellranger_pipestance_path <- "/path/to/your/pipeline/output/directory"
gbm <- load_cellranger_matrix(cellranger_pipestance_path)

gene_metadata <- fData(gbm)

# The number 2 is picked arbitrarily in the line below.
# Where "2" is placed you should place the column number that corresponds to your
# featureData's gene short names.

colnames(gene_metadata)[2] <- "gene_short_name"

gbm_cds <- new_cell_data_set(exprs(gbm),
        cell_metadata = pData(gbm),
        gene_metadata = gene_metadata,
        lowerDetectionLimit = 0.5,
        expressionFamily = negbinomial.size())
{% endhighlight %}

Monocle's sparse matrix support is provided by the <code>Matrix</code> package.
Other sparse matrix packages, such as <code>slam</code> or <code>SparseM</code> are not supported.
<!--
<h3 data-toc-text= "Estimate size factors">Estimate size factors<span class= "label label-danger">Required</span></h3>

<p> Finally, we'll also call a function that pre-calculates some information about the data.
Size factors help us normalize for differences in mRNA recovered across cells. </p>


{% highlight R %}
cds <- estimate_size_factors(cell_data_set)
{% endhighlight %}
 -->

<!-- <h2 data-toc-text= "Quality control">Quality control <span class= "label label-info">Recommended</span></h2> -->

<h2>Clustering and classifying your cells</h2>

<p>Single cell experiments are often performed on tissues containing many cell types. Monocle provides a simple set of functions you can use to group your cells according to their gene expression profiles into <emph>clusters</emph>. Often cells form clusters that correspond to one cell type or a set of highly related cell types.  Monocle uses techniques to do this that are widely accepted in single-cell RNA-seq analysis and similar to the approaches used by <a href="https://satijalab.org/seurat/">Seurat</a>, <a href="https://scanpy.readthedocs.io/en/stable/">scanpy</a>, and other tools.</p>

In this section, you will learn how to cluster cells using Monocle. We will demonstrate the main functions used for clustering with the <emph>C. elegans</emph> data from Cao & Packer et al. This study described how to do single-cell RNA-seq with combinatorial indexing in a protocol called "sci-RNA-seq". Cao & Packer et al used sci-RNA-seq to produce the first single-cell RNA-seq analysis of a whole animal, so there are many cell types represented in the data. You can learn more about the dataset and see how the authors performed the original analysis at the UW Genome Sciences <a href="http://atlas.gs.washington.edu/worm-rna/">RNA Atlas of the Worm</a> site.

You can load the data into Monocle 3 like this:

{% highlight R %}
### FIXME: Put these files on the web so they're accessible to others:
expression_matrix = readRDS("L2_expression.rda")
cell_metadata = readRDS("L2_cell_metadata.rda")
gene_annotation = readRDS("L2_gene_metadata.rda")

cds = new_cell_data_set(expression_matrix,
                         cell_metadata = cell_metadata,
                         gene_metadata = gene_annotation)

{% endhighlight %}

<h3>Pre-process the data</h3>

<p>Now that the data's all loaded up, we need to <emph>pre-process</emph> it. This step is where you tell Monocle how you want to normalize the data, whether to use <a href="https://en.wikipedia.org/wiki/Principal_component_analysis">Principal Components Analysis</a> (the standard for RNA-seq) or <a href="https://en.wikipedia.org/wiki/Latent_semantic_analysis">Latent Semantic Indexing</a> (common in ATAC-seq), and how to remove any batch effects. We will just use the standard PCA method. When using PCA, you should specify the number of principal components you want Monocle to compute. </p>

{% highlight R %}
cds = preprocess_cds(cds, num_dim = 100)
{% endhighlight %}

<p>It's a good idea to check that you're using enough PCs to capture most of the variation in gene expression across all the cells in the data set. You can look at the fraction of variation explained by each PC using <code>plot_pc_variance_explained()</code>:</p>

{% highlight R %}
plot_pc_variance_explained(cds)
{% endhighlight %}

<div class= "text-center">
    <img src= "{{site.baseurl}}/images/manual_images/L2_pc_variance_explained.png" width= 450>
</div>

<p>We can see that using more than 100 PCs would capture only a small amount of additional variation, and each additional PC makes downstream steps in Monocle slower.</p>
  
<h3>Reduce dimensionality and visualize the cells</h3>

<p>Now we're ready to visualize the cells. To do so, you can use either <a href="https://en.wikipedia.org/wiki/T-distributed_stochastic_neighbor_embedding">t-SNE</a>, which is very popular in single-cell RNA-seq, or <a href="https://github.com/lmcinnes/umap">UMAP</a>, which is increasingly common. Monocle uses UMAP by default, as we feel that it is both faster and better suited for clustering and trajectory analysis in RNA-seq. To reduce the dimensionality of the data down into the X, Y plane so we can plot it easily, call <code>reduce_dimension()</code>:</p>

{% highlight R %}
cds = reduce_dimension(cds)
{% endhighlight %}

<p>To plot the data, use Monocle's main plotting function, <code>plot_cells()</code>:</p>

{% highlight R %}
plot_cells(cds)
{% endhighlight %}

<div class= "text-center">
  <img src= "{{site.baseurl}}/images/manual_images/L2_umap_no_color.png" width= 760>
</div>

<p>Each point in the plot above represents a different cell in the <code>cell_data_set</code> object <code>cds</code></p>. As you can see the cells form many groups, some with thousands of cells, some with only a few. Cao & Packer annotated each cell according to type manually by looking at which genes it expresses. We can color the cells in the UMAP plot by the authors' original annotations using the <code>color_cells_by</code> argument to <code>plot_cells()</code>. 

{% highlight R %}
plot_cells(cds, color_cells_by="cao_cell_type")
{% endhighlight %}

<div class= "text-center">
  <img src= "{{site.baseurl}}/images/manual_images/L2_umap_color_by_cao_type.png" width= 760>
</div>
<p>You can see that many of the cell types land very close to one another in the UMAP plot.</p>

<p>Except for a few cases described in a moment, <code>color_cells_by</code> can be the name of any column in <code>colData(cds)</code>. Note that when <code>color_cells_by</code> is a categorical variable, labels are added to the plot, with each label positioned roughly in the middle of all the cells that have that label.</p>



<div class= "panel panel-info">
<div class= "panel-heading">
<h3 class= "panel-title" data-toc-skip>Faster clustering with UMAP</h3>
</div>
<div class= "panel-body">
<p>If you have a relatively large dataset (with >10,000 cells or more), you may want to take advantage of options that can accelerate UMAP. Passing <code>umap.fast_sgd=TRUE</code> to <code>reduce_dimension()</code> will use a fast stochastic gradient descent method inside of UMAP. If your computer has multiple cores, you can use the <code>cores</code> argument to make UMAP multithreaded. However, invoking <code>reduce_dimension()</code> with either of these options will make it produce slighly different output each time you run it. If this is acceptable to you, you could see signifant reductions in the running time of <code>reduction_dimension()</code>.</p>
</div>
</div>
    
<p>If you want, you can also use t-SNE to visualize your data. First, call reduce_dimension with <code>reduction_method="tSNE"</code>.</p>
{% highlight R %}
cds = reduce_dimension(cds, reduction_method="tSNE")
{% endhighlight %}

<p>Then, when you call <code>plot_cells()</code>, pass <code>reduction_method="tSNE"</code> to it as well:</p>

{% highlight R %}
plot_cells(cds, reduction_method="tSNE", color_cells_by="cao_cell_type")
{% endhighlight %}

<p>You can actually use UMAP and t-SNE on the same <code>cds</code> object - one won't overwrite the results of the other. But you must specify which one you want in downstream functions like <code>plot_cells</code>.</p>

<div class= "text-center">
    <img src= "{{site.baseurl}}/images/manual_images/L2_tsne_corrected_cao_type.png" width= 760>
</div>

<h3>Check for and remove batch effects</h3>
When performing gene expression analysis, it's important to check for <emph>batch effects</emph>, which are systematic differences in the transcriptome of cells measured in different experimental batches. These could be technical in nature, such as those introduced during the single-cell RNA-seq protocol, or biological, such as those that might arise from different litters of mice. How to recognize batch effects and account for them so that they don't confound your analysis can be a complex issue, but Monocle provides tools for dealing with them.  

<p>You should always check for batch effects when you perform dimensionality reduction. You should add a column to the <code>colData</code> that encodes which batch each cell is from. Then you can simply color the cells by batch. Cao & Packer et al included a "plate" annotation in their data, which specifies which sci-RNA-seq plate each cell originated from. Coloring the UMAP by plate reveals:</p>

{% highlight R %}
plot_cells(cds, color_cells_by="plate", label_cell_groups=FALSE)
{% endhighlight %}

<div class= "text-center">
  <img src= "{{site.baseurl}}/images/manual_images/L2_umap_plate.png" width= 760>
</div>

<p>Dramatic batch effects are not evident in this data. If the data contained more substantial variation due to plate, we'd expect to see groups of cells that really only come from one plate. Nevertheless, we can try and remove what batch effect is by re-running the <code>preprocess_cds()</code> function: </p>

{% highlight R %}
cds = preprocess_cds(cds, num_dim = 100, residual_model_formula_str = "~ plate")
cds = reduce_dimension(cds)
plot_cells(cds, color_cells_by="plate", label_cell_groups=FALSE)
{% endhighlight %}

<div class= "text-center">
  <img src= "{{site.baseurl}}/images/manual_images/L2_umap_corrected_plate.png" width= 760>
</div>

<h3>Group cells into clusters</h3>
Grouping cells into clusters is an important step in identifying the cell types represented in your data. Monocle uses a technique called <a href="https://en.wikipedia.org/wiki/Louvain_Modularity">Louvain community detection</a> to group cells. This approach was introduced by <a href="https://www.ncbi.nlm.nih.gov/pmc/articles/PMC4508757/">Levine et al</a> as part of the phenoGraph algorithm. You can cluster your cells using the <code>cluster_cells()</code> function, like this:

{% highlight R %}
cds = cluster_cells(cds, resolution=c(10^seq(-6,-1)))
plot_cells(cds)
{% endhighlight %}

<div class= "text-center">
  <img src= "{{site.baseurl}}/images/manual_images/L2_umap_color_by_cluster.png" width= 760>
</div>

<p>Note that now when we call <code>plot_cells()</code> with no arguments, it colors the cells by cluster according to default.</p>
<p>The <code>cluster_cells()</code> also divides the cells into larger, more well separated groups called <emph>partitions</emph>, using a statistical test from <a href=https://genomebiology.biomedcentral.com/articles/10.1186/s13059-019-1663-x">Alex Wolf et al</a>, introduced as part of their <a href="https://github.com/theislab/paga">PAGA</a> algorithm. You can visualize these partitions like this:</p>

{% highlight R %}
plot_cells(cds, color_cells_by="partition", group_cells_by="partition")
{% endhighlight %}

<div class= "text-center">
  <img src= "{{site.baseurl}}/images/manual_images/L2_umap_color_cells_by_partition.png" width= 760>
</div>

<p>Once you run <code>cluster_cells()</code>, the <code>plot_cells()</code> function will label each cluster of cells is labeled separately according to how you want to color the cells. For example, the call below colors the cells according to their cell type annotation, and each cluster is labeled according the most common annotation within it:</p>

{% highlight R %}
plot_cells(cds, color_cells_by="cao_cell_type")
{% endhighlight %}

<div class= "text-center">
  <img src= "{{site.baseurl}}/images/manual_images/L2_umap_corrected_cao_type.png" width= 760>
</div>


<p></p>
You can choose to label whole partitions instead of clusters by passing <code>group_cells_by="partition"</code>. You can also plot the top 2 labels per cluster by passing <code>labels_per_group=2</code> to <code>plot_cells()</code>. Finally, you can disable this labeling policy, making <code>plot_cells()</code> behave like it did before we called <code>cluster_cells()</code>, like this:</p>


{% highlight R %}
plot_cells(cds, color_cells_by="cao_cell_type", label_groups_by_cluster=FALSE)
{% endhighlight %}

<div class= "text-center">
  <img src= "{{site.baseurl}}/images/manual_images/L2_umap_corrected_cao_type_no_cluster_label.png" width= 760>
</div>

<!-- 

{% highlight R %}
pheatmap::pheatmap(log(table(clusters(cds), colData(cds)$cao_cell_type)+1),
                   clustering_method="ward.D2",
                   fontsize=6)
{% endhighlight %}

<div class= "text-center">
  <img src= "{{site.baseurl}}/images/manual_images/L2_cell_type_by_cluster.png" width= 760>
</div> -->

<h3>Find marker genes expressed by each cluster</h2>

<p>Once cells have been clustered, we can ask what genes makes them different from one another. To do that, start by calling the <code<>top_markers()</code> function:</p>

{% highlight R %}
marker_test_res = top_markers(cds, group_cells_by="partition", reference_cells=1000, cores=8)
{% endhighlight %}

<p></p>The data frame <code>marker_test_res</code> contains a number of metrics for how specifically expressed each gene is in each partition. We could group the cells according to cluster, partition, or any categorical variable in <code>colData(cds)</code>. You can rank the table according to one or more of the specificity metrics and take the top gene for each cluster. For example, <code>pseudo_R2</code> is one such measure. We can rank markers according to <code>pseudo_R2</code> like this:

{% highlight R %}
top_specific_markers = marker_test_res %>% 
    filter(marker_test_q_value < 0.05 & pseudo_R2 > 0.01) %>%
    group_by(cell_group) %>% 
    top_n(1, pseudo_R2)

top_specific_marker_ids = unique(top_specific_markers %>% pull(gene_id))
{% endhighlight %}

<p>Now, we can plot the expression and fraction of cells that express each marker in each group with the <code>plot_genes_by_group</code> function:</p>

{% highlight R %}
plot_genes_by_group(cds, 
                    top_specific_marker_ids, 
                    group_cells_by="partition", 
                    ordering_type="cluster_row_col")
{% endhighlight %}

<div class= "text-center">
  <img src= "{{site.baseurl}}/images/manual_images/L2_plot_top_partition_marker.png" width= 760>
</div>

<p>It's often informative to look at more than one marker, which you can do just by changing the first argument to <code>top_n()</code>:</p>
{% highlight R %}
top_specific_markers = marker_test_res %>% 
    filter(marker_test_q_value < 0.05 & pseudo_R2 > 0.01) %>%
    group_by(cell_group) %>% 
    top_n(3, pseudo_R2)

top_specific_marker_ids = unique(top_specific_markers %>% pull(gene_id))

plot_genes_by_group(cds, 
                    top_specific_marker_ids, 
                    group_cells_by="partition", 
                    ordering_type="cluster_row_col")
{% endhighlight %}

<div class= "text-center">
  <img src= "{{site.baseurl}}/images/manual_images/L2_plot_top3_partition_marker.png" width= 760>
</div>

There are many ways to compare and contrast clusters (and other groupings) of cells. We will explore them in great detail in the <a href = "{{
  site.baseurl }}/docs/#differential-expression-analysis">Differential expression analysis</a> section a bit later.

<h3>Annotate your cells according to type</h2>

<p>Identifying the type of each cell in your dataset is critical for many downstream analyses. There are several ways of doing this. One commonly used approach is to first cluster the cells and then assign a cell type to each cluster based on its gene expression profile. We've already seen how to use <code>top_markers()</code>. Reviewing literature associated with a marker gene often give strong indications of the identity of clusters that express it. In Cao & Packer <emph>>et al</emph>, the authors consulted literature and gene expression databases for markers restricted to each cluster in order to assign the identities contained in <code>colData(cds)$cao_cell_type</code>.</p>

<p>To assign cell types based on clustering, we begin by creating a new column in <code>colData(cds)</code> and initialize it with the values of <code>clusters(cds)</code>:</p>

{% highlight R %}
colData(cds)$assigned_cell_type = as.character(partitions(cds))
{% endhighlight %}

<p>Now, we can use the <code>dplyr</code>package's <code>recode()</code> function to remap each cluster to a different cell type:</p>
{% highlight R %}
colData(cds)$assigned_cell_type = dplyr::recode(colData(cds)$assigned_cell_type,
                                                "1"="Body wall muscle",
                                                "2"="Germline",
                                                "3"="Neurons",
                                                "4"="Seam cells",
                                                "5"="Coelomocytes",
                                                "6"="Pharyngeal epithelia",
                                                "7"="Unknown",
                                                "8"="Unknown",
                                                "9"="Intestinal/rectal muscle",
                                                "10"="Neurons",
                                                "11"="Neurons",
                                                "12"="Am/PH sheath cells",
                                                "13"="Unknown",
                                                "14"="Neurons",
                                                "15"="Neurons",
                                                "16"="Neurons",
                                                "17"="Pharyngeal gland",
                                                "18"="Neurons",
                                                "19"="Neurons",
                                                "20"="Neurons",
                                                "21"="Neurons",
                                                "22"="Neurons",
                                                "23"="Neurons",
                                                "24"="Neurons",
                                                "25"="Neurons",
                                                "26"="Neurons",
                                                "27"="Unknown",
                                                "28"="Pharyngeal gland",
                                                "29"="Neurons",
                                                "30"="Neurons",
                                                "31"="Neurons",
                                                "32"="Neurons",
                                                "33"="Pharyngeal muscle",
                                                "34"="Failed QC")
{% endhighlight %}

<p>Let's see how the new annotations look:</p>
{% highlight R %}
plot_cells(cds, group_cells_by="partition", color_cells_by="assigned_cell_type")
{% endhighlight %}

<div class= "text-center">
  <img src= "{{site.baseurl}}/images/manual_images/L2_plot_cells_by_initial_annotation.png" width= 760>
</div>

<p>Partition 7 has some substructure, and it's not obvious just from looking at the output of <code>top_markers()</code> what cell type or types it corresponds to. So we can isolate it with the <code>choose_cells()</code> function for further analysis:</p>

{% highlight R %}
cds_subset = choose_cells(cds)
{% endhighlight %}

<!-- 
I made choose_cells_recording by:
1) Using quicktime to screen record my interaction with the choose_cells shiny app
2) saving the MOV file to the manual_image directory. 
3) Converting it to a GIF using instructions found here: https://gist.github.com/dergachev/4627207
ffmpeg -i in.mov -s 600x400 -pix_fmt rgb24 -r 10 -f gif - | gifsicle --optimize=3 --delay=3 > out.gif 
-->

<div class= "text-center">
  <img src= "{{site.baseurl}}/images/manual_images/choose_cells_recording.gif" width= 760>
</div>

<p>Now we have a smaller <code>cell_data_set</code> object that contains just the cells from the partition we'd like to drill into. We can use <code>graph_test()</code> to identify genes that are differentially expressed in different subsets of cells from this partition:</p>

{% highlight R %}
pr_graph_test_res = graph_test(cds_subset, neighbor_graph="knn", cores=8)
pr_deg_ids = row.names(subset(pr_graph_test_res, morans_I > 0.01 & q_value < 0.05))
{% endhighlight %}

<p>We will learn more about <code>graph_test()</code> in the <a href = "{{
  site.baseurl }}/docs/#finding-modules-of-co-regulated-genes">Differential expression analysis</a> section later. We can take all the genes that vary across this set of cells and group those that have similar patterns of expression into <emph>modules</emph>: </p>

{% highlight R %}
gene_module_df = find_gene_modules(cds_subset[pr_deg_ids,], resolution=1e-3)
{% endhighlight %}

<p>Plotting these modules' aggregate expression values reveals which cells express which modues. </p>
{% highlight R %}
plot_cells(cds_subset, genes=gene_module_df, show_trajectory_graph=FALSE, label_cell_groups=FALSE)
{% endhighlight %}

<div class= "text-center">
  <img src= "{{site.baseurl}}/images/manual_images/L2_sex_partition_modules.png" width= 760>
</div>

<p>You can explore the genes in each module or conduct <a href="http://geneontology.org/">gene ontology enrichment analysis</a> on them to glean insights about which cell types are present. Suppose after doing this we have a good idea of what the cell types in the partition are. Let's see how they overlap with the clusters in the partition:</p>

{% highlight R %}
plot_cells(cds_subset, color_cells_by="cluster") 
{% endhighlight %}

<div class= "text-center">
  <img src= "{{site.baseurl}}/images/manual_images/L2_sex_partition_color_by_cluster.png" width= 760>
</div>

<p>Based on how the patterns line up, we'll make the following assignments:</p>
{% highlight R %}
colData(cds_subset)$assigned_cell_type = as.character(clusters(cds_subset)[colnames(cds_subset)])
colData(cds_subset)$assigned_cell_type = dplyr::recode(colData(cds_subset)$assigned_cell_type,
                                                "28"="Vulval precursors",
                                                "38"="Neurons",
                                                "39"="Unknown",
                                                "42"="Sex myoblasts",
                                                "27"="Sex myoblasts",
                                                "31"="Somatic gonad progenitors")
plot_cells(cds_subset, group_cells_by="cluster", color_cells_by="assigned_cell_type")
{% endhighlight %}

<p>Now we can transfer the annotations from the <code>cds_subset</code> object back to the full dataset:</p>

{% highlight R %}
colData(cds)[colnames(cds_subset),]$assigned_cell_type = colData(cds_subset)$assigned_cell_type
plot_cells(cds, group_cells_by="partition", color_cells_by="assigned_cell_type", labels_per_group=5)
{% endhighlight %}

<div class= "text-center">
  <img src= "{{site.baseurl}}/images/manual_images/L2_plot_cells_by_refined_annotation.png" width= 760>
</div>

<h3>Automated annotation with Garnett</h3>

<p>The above process for manually annotating cells by type can be laborious, and must be re-done if the underlying cluster changes. We recently developed <a href="https://cole-trapnell-lab.github.io/garnett/">Garnett</a>, a software toolkit for automatically annotating cells. Garnett classifies cells based on marker genes. If you've gone through the trouble of annotated your cells manually, Monocle can generate a file of marker genes that can be used with Garnett. This will help you annotate other datasets in the future or reannotate this one if you refine your analysis and update your clustering in the future.</p>

<p>To generate a Garnett file, first find the top markers that each annotated cell type expresses:</p>
{% highlight R %}
assigned_type_marker_test_res = top_markers(cds, 
                                            group_cells_by="assigned_cell_type", 
                                            reference_cells=1000, 
                                            cores=8)
{% endhighlight %}

<p>Then call <code>generate_garnett_marker_file</code>:</p>
{% highlight R %}
generate_garnett_marker_file(assigned_type_marker_test_res, file="./marker_file.txt")
{% endhighlight %}

<p><code>generate_garnett_marker_file</code></p> will produce a text file like this:
{% highlight console %}
> Cell type Pharyngeal epithelia
expressed: abu-6, gon-2, pqn-2, eyg-1, cutl-21

> Cell type Pharyngeal muscle
expressed: nspe-4, Y105C5B.5, Y52E8A.6

> Cell type Neurons
expressed: gei-18, htp-1, plk-3, F42G10.1, toca-2

> Cell type Coelomocytes
expressed: dig-1, prmn-1, inos-1, ZK593.3, C23H3.2, R11G1.6

> Cell type Unknown 2
expressed: cdk-1, Y49E10.4, D2024.4

> Cell type Pharyngeal gland
expressed: lys-8, C14B4.2

> Cell type Unknown
expressed: plk-1, nspc-20, nspc-15

> Cell type Germline
expressed: htp-2, mei-2, C56A3.8, Y57A10A.3, C16C8.13, EEED8.13, ztf-28, bath-4, K12H6.2

> Cell type Failed QC
expressed: T20B6.3, pqn-29, R13H4.8, T01B7.8, C04G6.7, C27A2.5, pqn-67, F41G3.3, Y47D3B.6, F41E6.11

> Cell type Intestinal/rectal muscle
expressed: mls-1, C15C8.6

> Cell type Body wall muscle
expressed: rme-2, T20D4.12

> Cell type Sex myoblasts
expressed: grd-14

> Cell type Seam cells
expressed: nhr-73, trcs-1, F54B11.10, W08G11.1

> Cell type Am/PH sheath cells
expressed: ZK822.4, T02B11.3, far-8, T11B7.5, vap-1, Y54G2A.10, R13D7.2, F11C7.2, K09C6.9, F52E1.2
{% endhighlight %}

<p>You may want to edit this file to add or remove markers based on literature or other information.</p>
<p>When you're ready run Garnett, load the package:</p>
{% highlight R %}
library(garnett)
{% endhighlight %}

<p>Now train a Garnett classifier based on your marker file like this:</p>
{% highlight R %}
colData(cds)$garnett_cluster = clusters(cds)
worm_classifier <- train_cell_classifier(cds = cds,
                                         marker_file = "./marker_file.txt",
                                         db=org.Ce.eg.db::org.Ce.eg.db,
                                         cds_gene_id_type = "ENSEMBL",
                                         num_unknown = 50,
                                         marker_file_gene_id_type = "SYMBOL",
                                         cores=8)
{% endhighlight %}

<p>Garnett classifiers can be applied to datasets other than the one they were trained on. We strongly encourage you to <a href="https://cole-trapnell-lab.github.io/garnett/docs/#submitting-a-classifier">share</a> your Garnett files and include them with your papers so that others can use them.</p> 

<p>We trained a Garnett model to classify <emph>C. elegans</emph> cells based on the L2 data. You can classify cells with it by first downloading and then passing it to the <code>classify_cells()</code> function:</p>

{% highlight R %}
load(url("https://cole-trapnell-lab.github.io/garnett/classifiers/ceWhole"))
cds = classify_cells(cds, ceWhole,
                           db = org.Ce.eg.db,
                           cluster_extend = TRUE,
                           cds_gene_id_type = "ENSEMBL")
plot_cells(cds, color_cells_by="cluster_ext_type")
{% endhighlight %}

<p>Here's how Garnett annotated the cells:</p>

{% highlight R %}
plot_cells(cds, color_cells_by="cluster_ext_type")
{% endhighlight %}

<div class= "text-center">
    <img src= "{{site.baseurl}}/images/manual_images/L2_umap_corrected_garnett_ext_type.png" width= 760>
</div>
  
<!-- {% highlight R %}
# Plot the overlap between clusters and annotated cell types:
pheatmap::pheatmap(log(table(partitions(cds), colData(cds)$cao_cell_type)+1),
                   clustering_method="ward.D2",
                   fontsize=6, width=5, height=8, filename="L2_cell_type_by_partition.png")
{% endhighlight %} -->

<h2>Constructing single cell trajectories </h2>

<p>   During development, in response to stimuli, and throughout life, cells
transition from one functional "state" to another. Cells in different states
express different sets of genes, producing a dynamic repetoire of proteins and
metabolites that carry out their work. As cells move between states, they undergo a
process of transcriptional re-configuration, with some genes being silenced and
others newly activated. These transient states are often hard to characterize
because purifying cells in between more stable endpoint states can be difficult
or impossible. Single-cell RNA-Seq can enable you to see these states without
the need for purification. However, to do so, we must determine where each cell
is in the range of possible states. </p>

<p>   Monocle introduced the strategy of using RNA-Seq for <em>single cell
trajectory analysis</em>. Rather than purifying cells into discrete states
experimentally, Monocle uses an algorithm to learn the sequence of gene
expression changes each cell must go through as part of a dynamic biological
process. Once it has learned the overall "trajectory" of gene expression
changes, Monocle can place each cell at its proper position in the trajectory.
You can then use Monocle's differential analysis toolkit to find genes regulated
over the course of the trajectory, as described in the section <a href = "{{
site.baseurl }}/monocle3_docs/#finding-genes-that-change-as-a-function-of-pseudotime">
Finding genes that change as a function of pseudotime </a>. If there are
multiple outcomes for the process, Monocle will reconstruct a "branched"
trajectory. These branches correspond to cellular "decisions", and Monocle
provides powerful tools for identifying the genes affected by them and involved
in making them. You can see how to analyze branches in the section <a href = "{{
site.baseurl }}/monocle3_docs/#analyzing-branches-in-single-cell-trajectories"> Analyzing
branches in single-cell trajectories </a>. 

<!-- Monocle relies on a machine learning
technique called <em>reversed graph embedding</em> to construct single-cell
trajectories. You can read more about the theoretical foundations of Monocle's
approach in the section <a href = "{{ site.baseurl }}/docs/#theory-behind-monocle">
Theory Behind Monocle </a> , or consult the references shown at the end of the
vignette.  -->
</p>

The workflow for reconstructing trajectories is very similar to the workflow for clustering, but it has a few additional steps. To illustrate the workflow, we will use another <emph>C. elegans</emph> data set, this one from <a href="http://dx.doi.org/10.1101/565549">Packer & Zhu et al</a>. Their study includes a time series analysis of whole developing embyros. We will examine a small subset of the data which includes most of the neurons. We will load it as we did with the L2 data:

{% highlight R %}
expression_matrix = readRDS(url("http://staff.washington.edu/hpliner/data/packer_embryo_expression.rds"))
cell_metadata = readRDS(url("http://staff.washington.edu/hpliner/data/packer_embryo_colData.rds"))
gene_annotation = readRDS(url("http://staff.washington.edu/hpliner/data/packer_embryo_rowData.rds"))

cds <- new_cell_data_set(expression_matrix,
                         cell_metadata = cell_metadata,
                         gene_metadata = gene_annotation)
{% endhighlight %}

<h3>Pre-process the data</h3>
<p>Pre-processing works exactly as in clustering analysis. This time, we will use a different strategy for batch correction, which replicates what <emph>Packer & Zhu et al</emph> did in their original analysis:</p>

{% highlight R %}
cds <- preprocess_cds(cds, num_dim = 100, residual_model_formula_str = "~ bg.300.loading + bg.400.loading + bg.500.1.loading + bg.500.2.loading + bg.r17.loading + bg.b01.loading + bg.b02.loading")
{% endhighlight %}

<h3>Reduce dimensionality and visualize the results</h3>
Next, we reduce the dimensionality of the data. However, unlike clustering, which works well with both UMAP and t-SNE, here we strongly urge you to use UMAP, the default method:

{% highlight R %}
cds <- reduce_dimension(cds)
plot_cells(cds, label_groups_by_cluster=FALSE,  color_cells_by = "cell.type") 
{% endhighlight %}

<p>As you can see, despite the fact that we are only looking at a small slice of this dataset, Monocle reconstructs a trajectory with numerous branches. Overlaying the manual annotations on the UMAP reveals that these branches are pricipally occupied by one cell type.  

<div class= "text-center">
  <img src= "{{site.baseurl}}/images/manual_images/embryo_umap_packer_cell_type.png" width= 760>
</div>

<p>As with clustering analysis, you can use <code>plot_cells()</code> to visualize how individual genes vary along the trajectory. Let's look at some genes with interesting patterns of expression in ciliated neurons:</p>
{% highlight R %}
ciliated_genes = c("che-1",
                   "hlh-17",
                   "nhr-6",
                   "dmd-6",
                   "ceh-36",
                   "ham-1")

plot_cells(cds, 
           genes=ciliated_genes, 
           label_cell_groups=FALSE, 
           show_trajectory_graph=FALSE) 
{% endhighlight %}

<div class= "text-center">
  <img src= "{{site.baseurl}}/images/manual_images/embryo_ciliated_markers.png" width= 760>
</div>

<p>We will learn how to identify the genes that are restricted to each outcome of the trajectory later on in the section <a href = "{{
  site.baseurl }}/monocle3_docs/#finding-genes-that-change-as-a-function-of-pseudotime">
  Finding genes that change as a function of pseudotime</a>.</p>


<h3>Cluster your cells </h3>
<p>Although cells may continuously transition from one state to the next with no discrete boundary between them, Monocle does not assume that all cells in the dataset descend from a common transcriptional "ancestor". In many experiments, there might in fact be multiple distinct trajectories. For example, in a tissue responding to an infection, tissue resident immune cells and stromal cells will have very different initial transcriptomes, and will respond to infection quite differently, so they should be a part of the same trajectory. </p>

<p>Monocle is able to learn when cells should be placed in the same trajectory as opposed to separate trajectories through its clustering procedure. Recall that we run <code>cluster_cells()</code>, each cell is assigned not only to a cluster but also to a <emph>partition</emph>. When you are learning trajectories, each partition will eventually become a separate trajectory. We run <code>cluster_cells()</code>as before.</p>
{% highlight R %}
cds <- cluster_cells(cds)
plot_cells(cds, color_cells_by = "partition")
{% endhighlight %}

<div class= "text-center">
  <img src= "{{site.baseurl}}/images/manual_images/embryo_umap_partition.png" width= 760>
</div>

<h3>Learn the trajectory graph</h3>
Next, we will fit a <emph>principal graph</emph> within each parition using the <code>learn_graph()</code> function:
{% highlight R %}
cds <- learn_graph(cds)
plot_cells(cds, 
           color_cells_by = "cell.type", 
           label_groups_by_cluster=FALSE,
           label_leaves=FALSE,
           label_branch_points=FALSE)
{% endhighlight %}

<div class= "text-center">
  <img src= "{{site.baseurl}}/images/manual_images/embryo_pr_graph_packer_cell_type.png" width= 760>
</div>

This graph will be used in many downstream steps, such as branch analysis and differential expression.

<h3>Order the cells in pseudotime</h3>
Once we've learned a graph, we are ready to order the cells according to their progress through the developmental program. Monocle measures this progress in <emph>pseudotime</emph>. The box below defines pseudotime. 

<div class= "panel panel-info">
<div class= "panel-heading">
<h3 class= "panel-title" data-toc-skip>What is pseudotime?</h3>
</div>
<div class= "panel-body">
<p><emph>Pseudotime</emph> is a measure of how much progress an individual cell has made through a process such as cell differentiation. </p>

<p>In many biological processes, cells do not progress in perfect synchrony.  In single-cell expression studies of processes such as cell differentiation, captured cells might be widely distributed in terms of progress.  That is, in a population of cells captured at exactly the same time, some cells might be far along, while others might not yet even have begun the process.  This asynchrony creates major problems when you want to understand the sequence of regulatory changes that occur as cells transition from one state to the next. Tracking the expression across cells captured at the same time produces a very compressed sense of a gene's kinetics, and the apparent variability of that gene's expression will be very high.</p>

<p>By ordering each cell according to its progress along a learned trajectory, Monocle alleviates the problems that arise due to asynchrony. Instead of tracking changes in expression as a function of time, Monocle tracks changes as a function of progress along the trajectory, which we term ``pseudotime''. Pseudotime is an abstract unit of progress: it's simply the distance between a cell and the start of the trajectory, measured along the shortest path. The trajectory's total length is defined in terms of the total amount of transcriptional change that a cell undergoes as it moves from the starting state to the end state.</p>
</div>
</div>

<p>In order to place the cells in order, we need to tell Monocle where the "beginning" of the biological process is. We do so by chosing regions of the graph that we mark as "roots" of the trajectory. In time series experiments, this can usually be accomplished by finding spots in the UMAP space that are occupied by cells from early time points:</p>
{% highlight R %}
plot_cells(cds, 
           color_cells_by = "embryo.time.bin", 
           label_cell_groups=FALSE, 
           label_leaves=TRUE,
           label_branch_points=TRUE,
           graph_label_size=1.5)
{% endhighlight %}

<div class= "text-center">
  <img src= "{{site.baseurl}}/images/manual_images/embryo_pr_graph_by_time.png" width= 760>
</div>

<p>The black lines show the structure of the graph. Note that the graph is not fully connected: cells in different partitions are in distinct components of the graph. The circles with numbers in them denote special points within the graph. Each <emph>leaf</emph>, denoted by light gray circles, corresponds to a different outcome (i.e. cell fate) of the trajectory. Black circles indicate branch nodes, in which cells can travel to one of several outcomes. You can control whether or not these are shown in the plot with the <code>label_leaves</code> and <code>label_branch_points</code> arguments to <code>plot_cells</code>.</p>

<p>Now that we have a sense of where the early cells fall, we can call <code>order_cells()</code>, which will calculate where each cell falls in pseudotime. In order to do so <code>order_cells()</code>needs you to specify the <emph>root nodes</emph> of the trajectory graph. If you don't provide them as an argument, it will launch a graphical user interface for selecting or or more root nodes.</p>

{% highlight R %}
cds = order_cells(cds)
{% endhighlight %}

<div class= "text-center">
    <img src= "{{site.baseurl}}/images/manual_images/choose_root_recording.gif" width= 760>
</div>

<p>In the above example, we just chose one location, but you could pick as many as you want. Plotting the cells and coloring them by pseudotime shows how they were ordered:</p>
  
{% highlight R %}
plot_cells(cds, 
           color_cells_by = "pseudotime", 
           label_cell_groups=FALSE, 
           label_leaves=FALSE,
           label_branch_points=FALSE,
           graph_label_size=1.5)
{% endhighlight %}

<div class= "text-center">
  <img src= "{{site.baseurl}}/images/manual_images/embryo_pr_graph_by_pseudotime.png" width= 760>
</div>
<p>Note that some of the cells are gray. This means they have <emph>infinite</emph> pseudotime, because they were not reachable from the root nodes that were picked. In general, any cell on a parition that lacks a root node will be assigned an infinite pseudotime. In general, you should choose at least one root per partition.</p>

<p>It's often desirable to specify the root of the trajectory programmatically, rather than manually picking it. The function below does so by first grouping the cells according to which trajectory graph node they are nearest to. Then, it calcuates what fraction of the cells at each node come from the earliest time point. Then it picks the node that is most heavily occupied by early cells and returns that as the root.</p>

{% highlight R %}
# a helper function to identify the root principal points:
get_earliest_principal_node <- function(cds, time_bin="130-170"){
  cell_ids <- which(colData(cds)[, "embryo.time.bin"] == time_bin)

  closest_vertex <-
    cds@principal_graph_aux[["UMAP"]]$pr_graph_cell_proj_closest_vertex
  closest_vertex <- as.matrix(closest_vertex[colnames(cds), ])
  root_pr_nodes <-
    igraph::V(principal_graph(cds)[["UMAP"]])$name[as.numeric(names
      (which.max(table(closest_vertex[cell_ids,]))))]

  root_pr_nodes
}
cds = order_cells(cds, root_pr_nodes=get_earliest_principal_node(cds))
{% endhighlight %}

<p>Passing the programatically selected root node to <code>order_cells()</code> via the <code>root_pr_node</code>argument yields:
{% highlight R %}
plot_cells(cds, 
           color_cells_by = "pseudotime", 
           label_cell_groups=FALSE, 
           label_leaves=FALSE,
           label_branch_points=FALSE,
           graph_label_size=1.5)
{% endhighlight %}

<div class= "text-center">
  <img src= "{{site.baseurl}}/images/manual_images/embryo_pr_graph_by_pseudotime_programmatically_ordered.png" width= 760>
</div>

<p>Note that we we could easily do this on a per-partition basis by first grouping the cells by partition using the <code>partitions()</code> function. This would result in all cells being assigned a finite pseudotime.

<h3>Working with 3D trajectories</h3>

{% highlight R %}
cds_3d = reduce_dimension(cds, max_components = 3)
cds_3d = cluster_cells(cds_3d)
cds_3d = learn_graph(cds_3d)
cds_3d = order_cells(cds_3d, root_pr_nodes=get_earliest_principal_node(cds))

cds_3d_plot_obj = plot_cells_3d(cds_3d, color_cells_by="partition")
{% endhighlight %}

<strong>XXX PUT 3D PLOT BACK!!</strong>

<!-- <iframe src="{{site.baseurl}}/images/manual_images/emb_3d_by_partition.html"
  height="600" width="100%"
  scrolling="no" seamless="seamless"
  frameBorder="0">
</iframe>
 -->


<h2>Differential expression analysis </h2>
Differential gene expression analysis is a common task in RNA-Seq experiments.  Monocle can help you find genes that are differentially expressed between groups of cells and assesses the statistical signficance of those changes. Monocle 3 includes a powerful system for finding genes that vary across cells of different types, were collected at different developmental time points, or that have been perturbed in different ways.

<p>There are two approaches for differential analysis in Monocle:</p>
<ul>
  <li><strong>Regression analysis</strong>: using <code>fit_models()</code>, you can evaluate whether each gene depends on variables such as time, treatments, etc.</li>
  <li><strong>Graph-autocorrelation analysis</strong>: using <code>graph_test()</code>, you can find genes that vary over a trajectory or between clusters.</li>
</ul>

<p>Monocle also comes with specialized functions for finding co-regulated modules of differentially expressed genes. Monocle also allows you to interactively interrogate specific clusters or regions of a trajectory (e.g. branch points) for genes that vary within them. 
  
<p>Let's examine these tools in turn.</p>

<h3>Regression analysis </h3>
<p> In this section, we'll explore how to use Monocle to find genes that are differentially expressed according to several different criteria. Performing differential expression analysis on all genes in a <a href = "https://rdrr.io/bioc/monocle/man/cell_data_set.html">cell_data_set</a> object can take anywhere from minutes to hours, depending on how complex the analysis is. To keep the vignette simple and fast, we'll be working with small sets of genes. Rest assured, however, that Monocle can analyze several thousands of genes even in large experiments, making it useful for discovering dynamically regulated genes during the biological process you're studying. </p>

<p> Let's begin with a small set of genes that we know are important in ciliated neurons to demonstrate Monocle's capabilities:</p>

{% highlight R %}
ciliated_genes = c("che-1",
                   "hlh-17",
                   "nhr-6",
                   "dmd-6",
                   "ceh-36",
                   "ham-1")
cds_subset = cds[rowData(cds)$gene_short_name %in% ciliated_genes,]
{% endhighlight %}

<p></p>The differential analysis tools in Monocle are extremely flexible. Monocle works by fitting a <emph>regression model</emph> to each gene. You can specify this model to account for various factors in your experiment (time, treatment, and so on). For example, In the embryo data, the cells were collected at different time points. We can test whether any of the genes above change over time in their expression by first fitting a <emph>generalized linear model</emph> to each one: </p>

\begin{equation}
  log(y_i) = \beta_0 + \beta_t x_t
\end{equation}

<p>where $y_i$ is a random variable corresponding to the expression values of gene $i$, $x_t$ is the time each cell was collected (in minutes), and the $\beta_t$ capture the effect of time on expression, and $\beta_0$ is an intercept term. We can identify genes that vary over time by fitting this model to each one, and then testing whether it's $\beta_t$ is significantly different from zero. To do so, we first call the <code>fit_models()</code> function:</p>

{% highlight R %}
gene_fits = fit_models(cds_subset, model_formula_str = "~embryo.time")
{% endhighlight %}

<p><code>gene_fits</code> is a <a href="https://tibble.tidyverse.org/">tibble</a> that contains a row for each gene. The <code>model</code> column contains generalized linear model objects, each of which aims to explain the expression of a gene across the cells using the equation above. The parameter <code>model_formula_str</code> should be a string specifying the model formula. The model formulae you use in your tests can include any term that exists as a column in the <code>colData</code> table, including those columns that are added by Monocle in other analysis steps. For example, if you use <code><a href = "https://rdrr.io/bioc/monocle/man/cluster_cells.html">cluster_cells</a></code>, you can test for genes that differ between clusters and partitions by using <code>~cluster</code> or <code>~partition</code> (respectively) as your model formula. You can also include multiple variables, for example  <code>~embryo.time + batch</code>, which can be very helpful for subtracting unwanted effects.

<p> Now let's see which of these genes have time-dependent expression. First, we extract a table of coefficients from each model using the <code>coefficient_table()</code> function:</p>
{% highlight R %}
fit_coefs = coefficient_table(gene_fits)
{% endhighlight %}

<p></p><code>fit_coefs</code> looks like this: </p>

<div style="width:750px; height:250px; overflow: auto">
  <table class= "table">
    <thead>
    <tr>
    <th>id</th>
    <th>gene_short_name</th>
    <th>num_cells_expressed</th>
    <th>status</th>
    <th>term</th>
    <th>estimate</th>
    <th>std_err</th>
    <th>test_val</th>
    <th>p_value</th>
    <th>normalized_effect</th>
    <th>model_component</th>
    <th>q_value</th>
    </tr>
    </thead>
    <tbody>
  {% for term in site.data.de_tests.emb_terms %}
    <tr>
    <td>{{ term.id }}</td>
    <td>{{ term.gene_short_name }}</td>
    <td>{{ term.num_cells_expressed }}</td>
    <td>{{ term.status }}</td>
    <td>{{ term.term }}</td>
    <td>{{ term.estimate }}</td>
    <td>{{ term.std_err }}</td>
    <td>{{ term.test_val }}</td>
    <td>{{ term.p_value }}</td>
    <td>{{ term.normalized_effect }}</td>
    <td>{{ term.model_component }}</td>
    <td>{{ term.q_value }}</td>
    </tr>
    <tr>
  {% endfor %}
</table>
</div>

<p>Note that the table includes one row for each <emph>term</emph> of each gene's model. We generally don't care about the intercept term $\beta_0$, so we can easily just extract the time terms:</p>

{% highlight R %}
emb_time_terms = fit_coefs %>% filter(term == "embryo.time")
{% endhighlight %}

<p>Now, let's pull out the genes that have a significant time component. <code>coefficient_table()</code> calculates tests each coefficient for whether it is significantly different than zero under the <a href="https://en.wikipedia.org/wiki/Wald_test">Wald test</a>. By default, <code>coefficient_table()</code> adjusts these p-values for <code<>multiple hypothesis testing</code> using the method of <a href="https://en.wikipedia.org/wiki/False_discovery_rate">Benjamini and Hochberg</a>. These adjusted values can be found in the <code>q_value</code> column. We can filter the results and control the false discovery rate as follows:

{% highlight R %}
emb_time_terms %>% filter (q_value < 0.05) %>%
  select(gene_short_name, term, q_value, estimate)
{% endhighlight %}

<div style="width:750px; overflow: auto">
  <table class= "table">
    <thead>
    <tr>
    <th>gene_short_name</th>
    <th>term</th>
    <th>q_value</th>
    <th>estimate</th>
    </tr>
    </thead>
    <tbody>
  {% for term in site.data.de_tests.emb_time_sig_terms %}
    <tr>
    <td>{{ term.gene_short_name }}</td>
    <td>{{ term.term }}</td>
    <td>{{ term.q_value }}</td>
    <td>{{ term.estimate }}</td>
    </tr>
    <tr>
  {% endfor %}
</table>
</div>

<p>We can see that five of the six genes significantly vary as a function of time. </p>

<p> Monocle also provides some easy ways to plot the expression of a small set of genes grouped by the factors you use during differential analysis.  This helps you visualize the differences revealed by the tests above.  One type of plot is a "violin" plot. </p>

{% highlight R %}
plot_genes_violin(cds_subset, group_cells_by="embryo.time.bin", ncol=2) +
    theme(axis.text.x=element_text(angle=45, hjust=1))
{% endhighlight %}

<div class= "text-center">
  <img src= "{{site.baseurl}}/images/manual_images/embryo_ciliated_markers_violin.png" width= 500>
</div>

<h3>Controlling for batch effects and other factors</h3>

<!-- TODO: Add violin plots in this section -->

{% highlight R %}
gene_fits = fit_models(cds_subset, model_formula_str = "~embryo.time + batch")
fit_coefs = coefficient_table(gene_fits)
fit_coefs %>% filter(term != "(Intercept)") %>%
  select(gene_short_name, term, q_value, estimate)
{% endhighlight %}

<div style="height: 250px; width:750px; overflow: auto">
  <table class= "table">
    <thead>
    <tr>
    <th>gene_short_name</th>
    <th>term</th>
    <th>q_value</th>
    <th>estimate</th>
    </tr>
    </thead>
    <tbody>
  {% for term in site.data.de_tests.emb_plus_batch_terms %}
    <tr>
    <td>{{ term.gene_short_name }}</td>
    <td>{{ term.term }}</td>
    <td>{{ term.q_value }}</td>
    <td>{{ term.estimate }}</td>
    </tr>
    <tr>
  {% endfor %}
</table>
</div>

<h3>Evaluating models of gene expression</h3>

<p>How good are these models at "explaining" gene expression? We can evaluate the fits of each model using the <code>evaluate_fits()</code> function:</p>

{% highlight R %}
evaluate_fits(gene_fits)
{% endhighlight %}

<div style="width:750px; overflow: auto">
  <table class= "table">
    <thead>
    <tr>
    <th>id</th>
    <th>gene_short_name</th>
    <th>num_cells_expressed</th>
    <th>status</th>
    <th>null_deviance</th>
    <th>df.null</th>
    <th>logLik</th>
    <th>AIC</th>
    <th>BIC</th>
    <th>deviance</th>
    <th>df_residual</th>
    </tr>
    </thead>
    <tbody>
  {% for gene in site.data.de_tests.emb_time_evals %}
    <tr>
    <td>{{ gene.id }}</td>
    <td>{{ gene.gene_short_name }}</td>
    <td>{{ gene.num_cells_expressed }}</td>
    <td>{{ gene.status }}</td>
    <td>{{ gene.null_deviance }}</td>
    <td>{{ gene.df_null }}</td>
    <td>{{ gene.logLik }}</td>
    <td>{{ gene.AIC }}</td>
    <td>{{ gene.BIC }}</td>
    <td>{{ gene.deviance }}</td>
    <td>{{ gene.df_residual }}</td>
    </tr>
    <tr>
  {% endfor %}
    </tbody>
</table>
</div>

<p>Should we include the batch term in our model of gene expression or not? Monocle provides a function <code>compare_models()</code> that can help you decide. Compare models takes two models and returns the result of a <a href="https://en.wikipedia.org/wiki/Likelihood-ratio_test">likelihood ratio test</a> between them. Any time you add terms to a model, it will improve the fit. But we should always to use the simplest model we can to explain our data. The likelihood ratio test helps us decide whether the improvement in fit is large enough to justify the complexity our extra terms introduce. You run <code>compare_models()</code> like this:</p>

{% highlight R %}
time_batch_models = fit_models(cds_subset,
                               model_formula_str = "~embryo.time + batch",
                               expression_family="negbinomial")
time_models = fit_models(cds_subset,
                        model_formula_str = "~embryo.time",
                        expression_family="negbinomial")
compare_models(time_batch_models, time_models) %>% select(gene_short_name, q_value)
{% endhighlight %}

<p>The first of the two models is called the <em>full</em> model. This model is essentially a way of predicting the expression value of each gene in a given cell knowing both what time it was collected and which batch of cells it came from. The second model, called the <em>reduced</em> model, does the same thing, but it only knows about the time each cell was collected.  Because the full model has more information about each cell, it will do a better job of predicting the expression of the gene in each cell. The question Monocle must answer for each gene is <em>how much better</em> the full model's prediction is than the reduced model's. The greater the improvement that comes from knowing the <em>batch</em> of each cell, the more significant the result of the likelihood ratio test.</p>

<p>As we can see, all of the genes' likelihood ratio tests are significant, indicating that there are substantial batch effects in the data. We are therefore justified in adding the <code>batch</code> term to our model.</p>

<div style="height: 250px; width:750px; overflow: auto">
  <table class= "table">
    <thead>
    <tr>
    <th>gene_short_name</th>
    <th>p_value</th>
    </tr>
    </thead>
    <tbody>
  {% for gene in site.data.de_tests.emb_model_lr_test %}
    <tr>
    <td>{{ gene.gene_short_name }}</td>
    <td>{{ gene.q_value }}</td>
    </tr>
    <tr>
  {% endfor %}
</table>
</div>

<!-- <h3 data-toc-text= "Choosing a distribution for your data">Choosing a distribution for your data <span class= "label label-danger">Required</span></h3>

<p> Monocle works well with both relative expression data and count-based measures (e.g. UMIs).
In general, it works best with transcript count data, especially UMI data.
Whatever your data type, it is <i>critical</i> that specify the appropriate distribution for it.
FPKM/TPM values are generally log-normally distributed, while UMIs or read counts are better modeled with the negative binomial.
To work with count data, specify the negative binomial distribution as the <code>expressionFamily</code> argument to <code><a href = "https://rdrr.io/bioc/monocle/man/new_cell_data_set.html">new_cell_data_set</a></code>: </p>
<p>
{% highlight R %}
#Do not run
HSMM <- new_cell_data_set(count_matrix,
      phenoData = pd,
      featureData = fd,
      expressionFamily=negbinomial.size())
{% endhighlight %}
</p>
<p>
There are several allowed values for <code>expressionFamily</code>, which expects a "family function" from the VGAM package:
</p>
<p>
<table class= "table">
<thead>
<tr>
<th>Family function</th>
<th>Data type</th>
<th>Notes</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>negbinomial.size()</code></td>
<td>UMIs, Transcript counts from experiments with spike-ins or <code><a href = "https://rdrr.io/bioc/monocle/man/relative2abs.html">relative2abs()</a></code>, raw read counts</td>
<td>Negative binomial distribution with fixed variance (which is automatically calculated by Monocle). Recommended for most users.</td>
</tr>
<tr>
<td><code>negbinomial()</code></td>
<td>UMIs, Transcript counts from experiments with spike-ins or <code><a href = "https://rdrr.io/bioc/monocle/man/relative2abs.html">relative2abs</a></code>, raw read counts</td>
<td>Slightly more accurate than <code>negbinomial.size()</code>, but much, much slower. Not recommended except for very small datasets.</td>
</tr>
<tr>
<td><code>tobit()</code></td>
<td>FPKM, TPM</td>
<td>Tobits are truncated normal distributions. Using <code>tobit()</code> will tell Monocle to log-transform your data where appropriate. Do not transform it yourself.</td>
</tr>
<tr>
<td><code>gaussianff()</code></td>
<td>log-transformed FPKM/TPMs, Ct values from single-cell qPCR</td>
<td>If you want to use Monocle on data you have already transformed to be normally distributed, you can use this function, though some Monocle features may not work well.</td>
</tr>
</tbody>
</table>
</p>
<p>
<div class= "panel panel-danger">
<div class= "panel-heading">
<h3 class= "panel-title" data-toc-skip>Use the right distribution!</h3>
</div>
<div class= "panel-body">
<strong>Using the wrong expressionFamily for your data will lead to bad results</strong>, errors from Monocle, or both.
However, if you have FPKM/TPM data, you can still use negative binomial if you first convert your relative expression values to transcript counts using <code><a href = "https://rdrr.io/bioc/monocle/man/relative2abs.html">relative2abs()</a></code>.
This often leads to much more accurate results than using <code>tobit()</code>. See the section on  <a href = "{{ site.baseurl }}/docs/#converting-tpm-fpkm-values-into-mrna-counts-alternative"> Converting TPM to mRNA Counts</a> for details.
</div>
</div>
</p> -->

<!--
  FIXME: Put this back when we have resolved https://github.com/cole-trapnell-lab/monocle3/issues/31
<h3>Finding Genes that Distinguish Cell Types </h3>

{%highlight R%}
to_be_tested <- row.names(subset(fData(HSMM),
    gene_short_name %in% c("UBC", "NCAM1", "ANPEP")))
cds_subset <- HSMM[to_be_tested,]
{%endhighlight%}

<p>However, we have to specify a <em>model formula</em> in the call to tell
Monocle that we care about genes with expression levels that depends on
<em>CellType</em>. Monocle's differential expression analysis works essentially
by fitting two models to the expression values for each gene, working through
each gene independently.

<p> To set up the test based on <em>CellType</em>, we simply call <code><a href = "https://rdrr.io/bioc/monocle/man/differentialGeneTest.html">differentialGeneTest</a></code> with a string specifying <em>fullModelFormulaStr</em>.  We don't have to specify the reduced model in this case, because the default of <em>~1</em> is what we want here. </p>

{% highlight R %}
diff_test_res <- differentialGeneTest(cds_subset,
          fullModelFormulaStr = "~CellType")
diff_test_res[,c("gene_short_name", "pval", "qval")]
{% endhighlight %}

<p> Note that all the genes are significantly differentially expressed as a
function of <em>CellType</em> except the housekeeping gene TBP, which we're
using a negative control. However, we don't know which genes correspond to
myoblast-specific genes (those more highly expressed in myoblasts versus
fibroblast specific genes.  We can again plot them with a jitter plot to see:
</p>

{%highlight R%}
plot_genes_jitter(cds_subset,
        grouping = "CellType",
        color_by = "CellType",
        nrow= 1,
        ncol = NULL,
        plot_trend = TRUE)
{%endhighlight%} -->

<!-- 
<h3>Comparing selected subsets of cells</h3>
<p>Often, you'll see one or more clusters and wonder what makes them different from other cells. Monocle provides several functions you can use to select cells of interest for downstream analysis </p>

{% highlight R %}
cds_subset = choose_cells()
{% endhighlight %}

<strong>XXX animated GIF of choosing cells</strong>

<p>Now that we have selected several specific clusters of cells, we can find genes that distinguish them:</p>
{% highlight R %}
cluster_models = fit_models(cds_subset, 
                            model_formula_str = "~cluster")
fit_coefs = coefficient_table(cluster_models)
fit_coefs %>% filter(grepl("cluster", term) %>%
  select(gene_short_name, term, q_value, estimate)
{% endhighlight %}

XXX TODO SHOW OUTPUT XXX -->

<h3>Graph-autocorrelation analysis for comparing clusters</h3>

<p>In the L2 worm data, we identified a number of clusters that were very distinct as neurons: </p>
{% highlight R %}
neurons_cds = cds[,colData(cds)$assigned_cell_type == "Neurons"]
plot_cells(neurons_cds, color_cells_by="partition")
{% endhighlight %}

<div class= "text-center">
  <img src= "{{site.baseurl}}/images/manual_images/L2_umap_neurons.png" width= 760>
</div>

<p>There are many subtypes of neurons, so perhaps the different neuron clusters correspond to different subtypes. To investigate which genes are expressed differentially across the clusters, we could use the regression analysis tools discussed above. However, Monocle provides an alternative way of finding genes that vary between groups of cells in UMAP or t-SNE space. The function <code>graph_test()</code> uses a statistic from spatial autocorrelation analysis called <a href="https://en.wikipedia.org/wiki/Moran%27s_I">Moran's I</a>, which Cao & Spielmann <emph>et al</emph> showed to be effective in finding genes that vary in single-cell RNA-seq datasets.</p>

<p>You can run <code>graph_test()</code> like this:</p>

{% highlight R %}
pr_graph_test_res = graph_test(neurons_cds, neighbor_graph="knn", cores=8)
pr_deg_ids = row.names(subset(pr_graph_test_res, q_value < 0.05))
{% endhighlight %}

<p>The data frame <code>pr_graph_test_res</code> has the Moran's I test results for each gene in the <code>cell_data_set</code>. If you'd like to rank the genes by effect size, sort this table by the <code>morans_I</code>column, which ranges from -1 to +1. A value of 0 indicates no effect, while +1 indicates perfect positive autocorrelation and suggests that a nearby cells have very similar values of a gene's expression. Significant values much less than zero are generally rare.</p>

<p>Positive values indicate a gene is expressed in a focal region of the UMAP space (e.g. specific to one or more clusters). But how do we associate genes with clusters? The next section explains how to collect genes into modules that have similar patterns of expression and associate them with clusters.</p>

<h3>Finding modules of co-regulated genes</h3>

<p>Once you have a set of genes that vary in some interesting way across the clusters, Monocle provides a means of grouping them into modules. You can call <code>find_gene_modules()</code>, which essentially runs UMAP on the genes (as opposed to the cells) and then groups them into modules using Louvain community analysis:</p>

{% highlight R %}
gene_module_df = find_gene_modules(neurons_cds[pr_deg_ids,], resolution=1e-2)
{% endhighlight %}

The data frame <code>gene_module_df</code> contains a row for each gene and identifies the module it belongs to. To see which modules are expressed in which clusters or partitions you can use two different approaches for visualization. The first is just to make a simple table that shows the aggregate expression of all genes in each module across all the clusters. Monocle provides a simple utility function called <code>aggregate_gene_expression</code> for this purpose:

{% highlight R %}
cell_group_df = tibble::tibble(cell=row.names(colData(neurons_cds)), cell_group=partitions(cds)[colnames(neurons_cds)])
agg_mat = aggregate_gene_expression(neurons_cds, gene_module_df, cell_group_df)
row.names(agg_mat) = stringr::str_c("Module ", row.names(agg_mat))
colnames(agg_mat) = stringr::str_c("Partition ", colnames(agg_mat))

pheatmap::pheatmap(agg_mat, cluster_rows=TRUE, cluster_cols=TRUE,
                   scale="column", clustering_method="ward.D2", 
                   fontsize=6)
{% endhighlight %}

<div class= "text-center">
  <img src= "{{site.baseurl}}/images/manual_images/L2_neuron_module_heatmap.png" width= 760>
</div>

<p>Some modules are highly specific to certain paritions of cells, while others are shared across multiple partitions. Note that <code>aggregate_gene_expression</code> can work with arbitrary groupings of cells and genes. You're not limited to looking at modules from <code>find_gene_modules()</code>, <code>clusters()</code>, and <code>partitions()</code>.</p>

The second way of looking at modules and their expression is to pass <code>gene_module_df</code> directly to <code>plot_cells()</code>. If there are many modules, it can be hard to see where each one is expressed, so we'll just look at a subset of them: 

{% highlight R %}
plot_cells(neurons_cds, 
           genes=gene_module_df %>% filter(module %in% c(16,38,33,42)), 
           group_cells_by="partition",
           color_cells_by="partition",
           show_trajectory_graph=FALSE)
{% endhighlight %}

<div class= "text-center">
  <img src= "{{site.baseurl}}/images/manual_images/L2_umap_neurons_selected_modules.png" width= 760>
</div>

<h3>Finding genes that change as a function of pseudotime </h3>
Identifying the genes that change as cells progress along a trajectory is a core objective of this type of analysis. Knowing the order in which genes go on and off can inform new models of development. For example, <a href="http://dx.doi.org/10.1016/j.cell.2018.12.003">Sharon and Chawla et al</a> recently analyzed pseudotime-dependent genes to arrive a whole new model of how islets form in the pancreas.</p>

<p>Let's return to the embryo data:</p>

{% highlight R %}
plot_cells(cds, 
           color_cells_by = "cell.type", 
           label_groups_by_cluster=FALSE,
           label_leaves=FALSE,
           label_branch_points=FALSE) 
{% endhighlight %}

<div class= "text-center">
  <img src= "{{site.baseurl}}/images/manual_images/embryo_pr_graph_packer_cell_type.png" width= 760>
</div>

<p>How do we find the genes that are differentially expressed on the different paths through the trajectory? How do we find the ones that are restricted to the beginning of the trajectory? Or excluded from it?</p>

<p>Once again, we turn to <code>graph_test(), this time passing it <code>neighbor_graph="principal_graph"</code>, which tells it to test whether cells at similar positions on the trajectory have correlated expression </code>:</p>

{% highlight R %}
ciliated_cds_pr_test_res = graph_test(cds, neighbor_graph="principal_graph", cores=4)
pr_deg_ids = row.names(subset(ciliated_cds_pr_test_res, q_value < 0.05))
{% endhighlight %}

<p>Here are a couple of interesting genes that score as highly significant according to <code>graph_test()</code>:</p>

{% highlight R %}
plot_cells(cds, genes=c("hlh-4", "gcy-8", "dac-1", "oig-8"), 
           show_trajectory_graph=FALSE,
           label_cell_groups=FALSE,
           label_leaves=FALSE)
{% endhighlight %}

<div class= "text-center">
  <img src= "{{site.baseurl}}/images/manual_images/embryo_umap_selected_markers.png" width= 760>
</div>

<p>As before, we can collect the trajectory-variable genes into modules:</p>

{% highlight R %}
gene_module_df = monocle3:::find_gene_modules(cds[pr_deg_ids,], resolution=c(0,10^seq(-6,-1)))
{% endhighlight %}

<p>Here we plot the aggregate module scores within each group of cell types as annotated by Packer & Zhu <emph>et al</emph>:</p>

{% highlight R %}
cell_group_df = tibble::tibble(cell=row.names(colData(cds)), cell_group=colData(cds)$cell.type)
agg_mat = aggregate_gene_expression(cds, gene_module_df, cell_group_df)
row.names(agg_mat) = stringr::str_c("Module ", row.names(agg_mat))
pheatmap::pheatmap(agg_mat,
                    scale="column", clustering_method="ward.D2")
{% endhighlight %}

<div class= "text-center">
  <img src= "{{site.baseurl}}/images/manual_images/emb_pseudotime_module_heatmap.png" width= 760>
</div>

We can also pass <code>gene_module_df</code> to <code>plot_cells()</code> as we did when we compared clusters in the L2 data above.

{% highlight R %}
plot_cells(cds, 
           genes=gene_module_df %>% filter(module %in% c(29,20, 11,22)), 
           label_cell_groups=FALSE,
           show_trajectory_graph=FALSE)
{% endhighlight %}

<div class= "text-center">
  <img src= "{{site.baseurl}}/images/manual_images/embryo_umap_selected_pseudotime_modules.png" width= 760>
</div>

<p>Monocle offers another plotting function that can sometimes give a clearer view of a gene's dynamics along a single path. Let's pick one such path, the AFD cells, which are found in clusters 22, 38, and 35:</p>
{% highlight R %}
plot_cells(cds, show_trajectory_graph=FALSE)
{% endhighlight %}

<div class= "text-center">
  <img src= "{{site.baseurl}}/images/manual_images/embryo_umap_cluster.png" width= 760>
</div>

<p>The function <code>plot_genes_in_pseudotime()</code> takes a small set of genes and shows you their dynamics as a function of pseudotime:</p>
{% highlight R %}
AFD_genes = c("gcy-8", "dac-1", "oig-8")
AFD_lineage_cds = cds[rowData(AFD_lineage_cds)$gene_short_name %in% AFD_genes,
                      clusters(cds) %in% c(22, 28, 35)]

plot_genes_in_pseudotime(AFD_lineage_cds, 
                         color_cells_by="embryo.time.bin",
                         min_expr=0.5)
{% endhighlight %}

<div class= "text-center">
  <img src= "{{site.baseurl}}/images/manual_images/embryo_AFD_dynamic_genes.png" width= 500>
</div>

<p>You can see that <emph>dac-1</emph> is activated before the other two genes.</p>

<h3>Analyzing branches in single-cell trajectories </h3>

Analyzing the genes that are regulated around trajectory branch points often provides insights into the genetic circuits that control cell fate decisions. Monocle can help you drill into a branch point that corresponds to a fate decision in your system. Doing so is as simple as selecting the cells (and branch point) of interest with <code>choose_cells(): 

{% highlight R %}
cds_subset = choose_cells(cds)
{% endhighlight %}


<div class= "text-center">
  <img src= "{{site.baseurl}}/images/manual_images/choose_branch_recording.gif" width= 760>
</div>

<p> And then calling <code>graph_test()</code> on the subset. This will identify genes with interesting patterns of expression that fall only within the region of the trajectory you selected, giving you a more refined and relevant set of genes.</p>
{% highlight R %}
subset_pr_test_res = graph_test(cds_subset, cores=4)
pr_deg_ids = row.names(subset(subset_pr_test_res, q_value < 0.05))
{% endhighlight %}

<p>Grouping these genes into modules can reveal fate specific genes or those that are activate immediate prior to or following the branch point:</p>

{% highlight R %}
gene_module_df = monocle3:::find_gene_modules(cds_subset[pr_deg_ids,], resolution=1e-2)
{% endhighlight %}

<p>We will organize the modules by their similarity (using <code>hclust</code>) over the trajectory so it's a little easier to see which ones come on before others:</p>

{% highlight R %}
cell_group_df = tibble::tibble(cell=row.names(colData(cds_subset)), cell_group=clusters(cds_subset)[colnames(cds_subset)])
agg_mat = aggregate_gene_expression(cds_subset, gene_module_df, cell_group_df)
module_dendro = hclust(dist(agg_mat))
gene_module_df$module <- factor(gene_module_df$module, levels = row.names(agg_mat)[module_dendro$order])

plot_cells(cds_subset, 
           genes=gene_module_df, 
           label_cell_groups=FALSE,
           show_trajectory_graph=FALSE)
{% endhighlight %}

<p>
<p>
<div class= "text-center">
  <img src= "{{site.baseurl}}/images/manual_images/embryo_umap_AFD_modules.png" width= 760>
</div>

<h2>Major updates in Monocle 3 </h2>

<p>Monocle 3 has been re-engineered to analyze large, complex single-cell datasets. The algorithms at the core of Monocle 3 are highly scalable and can handle millions of cells. Monocle 3 adds some powerful new features that enable the analysis of organism- or embryo-scale experiments:</p>

<ul>
    <li>A better structured workflow to learn developmental trajectories.
    <li>Support for the <a href="https://github.com/lmcinnes/umap">UMAP</a> algorithm to initialize trajectory inference.
    <li>Support for trajectories with multiple roots.
    <li>Ways to learn trajectories that have loops or points of convergence.
    <li>Algorithms that automatically partition cells to learn disjoint or parallel trajectories using ideas from <a href="https://www.biorxiv.org/content/early/2017/10/25/208819">"approximate graph abstraction"</a>.
    <li>A new statistical test for genes that have trajectory-dependent expression. This replaces both the old <code>differentialGeneTest()</code> function and <code>BEAM()</code>.
    <li>A 3D interface to visualize trajectories and gene expression.
</ul>

<p>Most of the algorithmic details in Monocle 3 are described in <a href="http://dx.doi.org/10.1038/s41586-019-0969-x">Cao & Spielmann <emph>et al</emph></a>. </p>
<!-- <p>Monocle 2 is a near-complete re-write of Monocle 1. Monocle 2 is geared towards larger, more complex single-cell RNA-Seq experiments than those possible at the time Monocle 1 was written.
It's also redesigned to support analysis of mRNA counts, which were hard to estimate experimentally in early versions of single-cell RNA-Seq.
Now, with spike controls or UMIs, gene expression can  be measured in mRNA counts. Analysis of these counts is typically easier and more accurate than relative expression values, and we encourage all users to adopt an mRNA-count centered workflow.
Numerous Monocle functions have been re-written to take advantage of the nicer statistical properties of mRNA counts.
For example, we adopt the dispersion modeling and variance-stabilization techniques introduced by DESeq <a href = "https://genomebiology.biomedcentral.com/articles/10.1186/gb-2010-11-10-r106">[6]</a> during differential analysis, dimensionality reduction, and other steps.

<p>Trajectory reconstruction in Monocle 2 is vastly more robust, faster, and more powerful than in Monocle 1. Monocle 2 uses an advanced nonlinear reconstruction algorithm called DDRTree <a href= "http://dl.acm.org/citation.cfm?id= 2783309">[7]</a>, described below in the section <a href = "{{ site.baseurl }}/docs/#theory-behind-monocle"> Theory Behind Monocle </a>. This algorithm can expose branches that are hard to see with the less powerful linear technique used in Monocle 1.
The algorithm is also far less sensitive to outliers, so careful QC and selection of high quality cells is less critical.
Finally, DDRTree is much more robust in that it reports qualititatively similar trajectories more consistently when you vary the number of cells in the experiment.
Although which genes are included in the ordering still greatly impact the trajectory, varying them also produces more qualititatively consistent trajectories than the previous linear technique.

<p>Because Monocle 2 is so much better at finding branches, it also includes some additional tools to help you interpret them. <a href = "https://rdrr.io/bioc/monocle/man/BEAM.html">Branch expression analysis modeling (BEAM)</a> is a new test for analyzing specific branch points <a href= "https://www.ncbi.nlm.nih.gov/pubmed/28114287">[8]</a>. <a href = "https://rdrr.io/bioc/monocle/man/BEAM.html">BEAM</a> reports branch-dependent genes, and Monocle 2 includes some new visualization functions to help you inspect these genes. Overall, we find that branching is pervasive in diverse biological processes, and thus we expect <a href = "https://rdrr.io/bioc/monocle/man/BEAM.html">BEAM</a> will be very useful to those analyzing single-cell RNA-Seq data in many settings.

<p>Monocle 2 also includes functionality that is inspired by other packages that weren't available when Monocle 1 was written. For example, much of Monocle 2's clustering strategy is similar to
Seurat <a href= "https://www.ncbi.nlm.nih.gov/pubmed/25867923">[9]</a> from Rahul Satija's lab.

<p>A manuscript describing Monocle 2 and the general stragegy of using reversed
graph embedding for single-cell trajectory analysis is available on the bioRxiv <a href= "http://www.biorxiv.org/content/early/2017/02/21/110668">[10]</a>.

<h2>Theory Behind Monocle </h2>

<h3 data-toc-text= "dpFeature">dpFeature: Selecting features from dense cell clusters </h3>


<p>Appling algorithms like t-SNE to cells transiting through a continuous process like cell differentiation often groups the cells into clusters that do not necessarily reflect their progression through the process. Nevertheless, the genes that are differentially expressed by cells the clusters are often highly informative markers of each cell's progress through the trajectory. That is, clustering algorithms like t-SNE can find often genes that vary over the trajectory, but not the trajectory itself. We designed a simple procedure to identify these genes for use in trajectory reconstruction.

<p>The dpFeature procedure works as follows.
First, dpFeature excludes genes that only expressed in a very small percentage of cells (by default, <em>5%</em>).
Second, dpFeature performs PCA on the remaining genes in order to identify the principal components that explain a substantial amount of variance in the data.
These top PCs are then used to initialize t-SNE, which projects the cells into two-dimensional t-SNE space.
Next, dpFeature uses a recently developed clustering algorithm, called "density peak" clustering <a href = "http://science.sciencemag.org/content/344/6191/1492">[4]</a> to cluster the cells in the two-dimensional t-SNE space.
The density peak clustering algorithm calculates each cell's local density (&Rho;) and its distance (&Delta;) to another cell with higher density.
The &Rho; and &Delta; values for each cell can be plotted in a so-called "decision plot" in order to select thresholds that define "peaks" in the t-SNE space.
Cells with high local density that are far away from other cells with high local density correspond to the density peaks.
These density peaks nucleate clusters: all other cells will be associated with the nearest density peak cell.
Finally, we identify genes that differ between the clusters by performing a likelihood ratio test between using a generalized linear model that knows the cluster to which each cell is assigned and a model that doesn't.
We then select (by default) the top 1,000 significantly differentially expressed genes as the ordering genes for the trajectory reconstruction. -->


<h2>Appendices</h2>

<h3>Reversed graph embedding </h3>

<p> Single-cell expression datasets are some of the largest and most complex encountered
in genomics. Even the smallest single-cell RNA-Seq experiments sample hundreds of cells, measuring the
expression level of the more than 20,000 genes in each cell. Visualizing these
datasets, identifying cells of different types, and comparing them to one another
all pose major bioinformatics challenges. </p>

<p> <em>Manifold learning</em> is a common strategy for dealing with complex, high-dimensional
data. The premise of this approach is simple: the data may reside in a very high-dimensional space,
but the intrinsic structure of the dataset is much simpler. Moreover, the data
are not random - they are generated by a process that can be understood by
inspecting the global structure of the dataset. For example, a single single-cell RNA-Seq
experiment may reside in 20,000 dimensions, but the cells might all lie on or "near"
a curve <em>embedded</em> within a much lower dimensional space. For example, we
might expect that cells in different phases of the cell cycle be distributed along
a closed loop. Indeed a recent large-scale single-cell RNA-Seq study found exactly
that <a href= "https://www.ncbi.nlm.nih.gov/pubmed/26000488">[11]</a>. </p>

<p>Manifold learning often involves <em>dimensionality reduction</em> techniques as a
first step. Conventional dimensionality reduction approaches (for
example, PCA, ICA, Isomap, LLE, etc.) are limited in their ability to explictly
recover the intrinisic structure from the data. </p>

<p>Monocle 2 uses a technique called <em>reversed graph embedding</em> <a href= "http://www.biorxiv.org/content/early/2017/02/21/110668">[10,</a> <a href= "http://ieeexplore.ieee.org/document/7769209/?reload=true">12]</a>  to learn the
structure of the manifold that describes a single-cell experiment. It simultaneously: </p>

<ol>
<li> Reduces high dimensional expression data into a lower dimension space.
<li> Learns an explicit, smooth manifold that generates the data.
<li> Assigns each cell to its position on that manifold
</ol>

<p>Together, these tasks allow Monocle 2 to order cells in pseudotime in an entirely
unsupervised, data-driven way. Importantly, Monocle 2 learns manifolds that are
trees without needing any <em>a priori</em> information about the structure of the
tree. Users do not need to provide Monocle 2 with constraints on the number of branches, etc.
These are learned from the data. This allows Monocle 2 to to discriminate between
linear and branched trajectories automatically. To our knowledge, Monocle 2 is the first
trajectory reconstruction algorithm to learn smooth tree-like manifolds without
needing to know its high-level structure ahead of time.

<p>Reversed graph embedding simultaneously learns a <em>principal graph</em> that
approximates the manifold, as well as a function that maps points on the graph
(which is embedded in low dimensions) back to the original high dimensional space.
Reversed graph embedding aims to learn both a set of <em>latent points</em>
$$ \mathcal{Z} = \{\mathbf{z}_1, ..., \mathbf{z}_M\}$$corresponding to the input data
that reside in the low-dimensional space along with a graph $\mathcal{G}$ that
connects them. This graph approximates the manifold. In order to map points on
the manifold back to the original high-dimensional input space, we also need to
learn a function $f_{\mathcal{G}}$.

<p>Learning a good reversed graph embedding can be described as an optimization problem that
joint captures the positions of the latent points $\mathbf{z}$, the graph $\mathcal{G}$, and the function
$f_\mathcal{G}$.

<p>To learn the positions of the latent points $\mathbf{z}$, we must optimize:

\begin{equation}
\mathop{min}_{f_g \in \mathcal{F}} \mathop{min}_{\{\mathbf{z}_1, ...,
\mathbf{z}_M\}} \sum_{i = 1}^N ||\mathbf{x}_i - f_g (\mathbf{z}_i)||^2
\end{equation}

<p>Given a set of latent point coordinates, the optimization of graph inference can
be represented as:

\begin{equation} \label{eq:mintree}
\mathop{min}_{f_\mathcal{G} \in \mathcal{F}} \mathop{min}_{\{\mathbf{z}_1, ..., \mathbf{z}_M\}} \sum_{(V_i, V_j) \in
\mathcal{E}} b_{i,j}||f_g(\mathbf{z}_i) - f_g(\mathbf{z}_j)||^2
\end{equation}

<p>where
$\mathcal{X} = \{ \mathbf{x}_1, ..., \mathbf{x}_N\}$ are the original
single-cell expression profiles. The $V_i$ are the the vertices of the
undirected graph $\mathcal{G} = (\mathcal{V}, \mathcal{E})$. The weights for the
edge in $\mathcal{E}$ are encoded as $b_{ij}$.

<p>The first optimization problem aims to position the latent points such that their
image under $f_\mathcal{G}$ (that is, their corresponding positions in the high-dimensional space)
will be "close" to the input data. The second optimization aims to keep latent
points that are close to one another in the low dimensional space close to one
another in the high dimensional space as well. These two goals must be balanced
against one another. Reversed graph embedding achieves this through the parameter
$\lambda$

\begin{equation}
\mathop{min}_{\mathcal{G} \in \hat{\mathcal{G}}_b}\mathop{min}_{f_g \in \mathcal{F}} \mathop{min}_{\{\mathbf{z}_1, ...,
\mathbf{z}_M\}} \sum_{i = 1}^N ||\mathbf{x}_i - f_g (\mathbf{z}_i)||^2 + \frac{\lambda}{2} \sum_{(V_i, V_j) \in \mathcal{E}}
b_{i,j}||f_g(\mathbf{z}_i) - f_g(\mathbf{z}_j)||^2
\end{equation}

<p>Reversed graph embedding requires a feasible set $\hat{\mathcal{G}}_b$ of graphs and a
mapping function $f_\mathcal{G}$. In practice, implementing reversed graph embedding
requires that we place some constraints on $\hat{\mathcal{G}}_b$ and $f_\mathcal{G}$.
As work on reversed graph embedding continues, we anticipate that more general
schemes that consider a wider range of feasible graphs and mapping functions will
become available. Monocle users should expect more general reversed graph embedding
schemes in future versions.

<p>Mao <em>et al</em> initially described two specific ways to implement the general framework
of reversed graph embedding. Both are briefly summarized below. See the original
paper on DDRTree for more details. Monocle 2 uses the second scheme, but can easily be
run in a mode that corresponds to the first.



<h2>Citation </h2>


If you use Monocle to analyze your experiments, please cite:

{% highlight R %}

citation("monocle")

##   Cole Trapnell and Davide Cacchiarelli et al (2014): The dynamics
##   and regulators of cell fate decisions are revealed by
##   pseudo-temporal ordering of single cells. Nature Biotechnology
##
##   Xiaojie Qiu, Andrew Hill, Cole Trapnell et al (2017):
##   Single-cell mRNA quantification and differential analysis with
##   Census. Nature Methods
##
##   Xiaojie Qiu, Cole Trapnell et al (2017): Reverse graph embedding
##   resolves complex single-cell developmental trajectories. BioRxiv
##
##   To see these entries in BibTeX format, use 'print(<citation>,
##   bibtex=TRUE)', 'toBibtex(.)', or set
##   'options(citation.bibtex.max= 999)'.

{% endhighlight %}


<h2>Acknowledgements </h2>

Monocle was originally built by Cole Trapnell and Davide Cacchiarelli, with substantial design input John Rinn and Tarjei Mikkelsen. We are grateful to Sharif Bordbar, Chris Zhu, Amy Wagers and the Broad RNAi platform for technical assistance, and Magali Soumillon for helpful discussions. Cole Trapnell was supported by a Damon Runyon Postdoctoral Fellowship. Davide Cacchiarelli was supported by a Human Frontier Science Program Fellowship. Cacchiarelli and Mikkelsen were also supported by the Harvard Stem Cell Institute. John Rinn was the Alvin and Esta Star Associate Professor. This work was supported by NIH grants 1DP2OD00667, P01GM099117, and P50HG006193-01. This work was also supported in part by the Single Cell Genomics initiative, a collaboration between the Broad Institute and Fluidigm Inc.

Monocle versions 2 and 3 were developed by Cole Trapnell's lab. Significant portions were written by Xiaojie Qiu and Hannah Pliner. The work was supported by NIH grant 1DP2HD088158 as well as an Alfred P. Sloan Foundation Research Fellowship.

This vignette was created from Wolfgang Huber's Bioconductor vignette style document, and patterned after the vignette for <em>DESeq</em>, by Simon Anders and Wolfgang Huber.


<h2>References </h2>

<ol>
  <li>Cole Trapnell*, Davide Cacchiarelli*, Jonna Grimsby, Prapti Pokharel, Shuqiang Li, Michael Morse, Niall J. Lennon, Kenneth J. Livak, Tarjei S. Mikkelsen, and John L. Rinn.<br/>
  <a href = "http://www.nature.com/nbt/journal/v32/n4/abs/nbt.2859.html">
  The dynamics and regulators of cell fate decisions are revealed by pseudotemporal ordering of single cells</a>.<br/> Nature Biotechnology, 2014.<br/><br/> </li>

  <li>Junyue Cao*, Jonathan S. Packer*, Vijay Ramani, Darren A. Cusanovich, Chau Huynh, Riza Daza, Xiaojie Qiu, Choli Lee, Scott N. Furlan, Frank J. Steemers, Andrew Adey, Robert H. Waterston, Cole Trapnell**, Jay Shendure** .<br/>
  <a href = "http://http//science.sciencemag.org/content/357/6352/661">
  Comprehensive single-cell transcriptional profiling of a multicellular organism</a>.<br/>Science, 2017.<br/><br/>  </li>

  <li>Jacob H. Levine, Erin F. Simonds, Sean C. Bendall, Kara L. Davis, El-ad D. Amir, Michelle Tadmor, Oren Litvin, Harris Fienberg, Astraea Jager, Eli Zunder, Rachel Finck, Amanda L. Gedman, Ina Radtke, James R. Downing, Dana Pe’er** and Garry P. Nolan**.<br/>
    <a href = "https://www.ncbi.nlm.nih.gov/pmc/articles/PMC4508757/">
      Data-driven phenotypic dissection of AML reveals progenitor-like cells that correlate with prognosis</a>.<br/>Cell, 2015.<br/><br/>  </li>
  
  <li>F. Alexander Wolf,, Fiona K. Hamey, Mireya Plass, Jordi Solana, Joakim S. Dahlin, Berthold Göttgens, Nikolaus Rajewsky, Lukas Simon and Fabian J. Theis<br/>
    <a href = "https://genomebiology.biomedcentral.com/articles/10.1186/s13059-019-1663-x">
      PAGA: graph abstraction reconciles clustering with trajectory inference through a topology preserving map of single cells</a>.<br/>Genome biology, 2018.<br/><br/>  </li>

  <li>Junyue Cao*, Malte Spielmann*, Xiaojie Qiu, Xingfan Huang, Daniel M. Ibrahim, Andrew J. Hill1, Fan Zhang, Stefan Mundlos, Lena Christiansen, Frank J. Steemers, Cole Trapnell**, and Jay Shendure** <br/>
    <a href = "http://dx.doi.org/10.1038/s41586-019-0969-x">
          The single-cell transcriptional landscape of mammalian organogenesis</a>.<br/>Nature, 2019.<br/><br/>  </li>

  <li>Jonathan S. Packer*, Qin Zhu*, Chau Huynh, Priya Sivaramakrishnan, Elicia Preston, Hannah Dueck, Derek Stefanik, Kai Tan, Cole Trapnell, Junhyong Kim**, Robert H. Waterston**, John I. Murray** <br/>
    <a href = "http://dx.doi.org/10.1101/565549">
      A lineage-resolved molecular atlas of C. elegans embryogenesis at single cell resolution</a>.<br/>bioRxiv, 2019.<br/><br/>  </li>
  
  <li>Nadav Sharon*, Raghav Chawla*, Jonas Mueller, Jordan Vanderhooft, Luke James Whitehorn, Benjamin Rosenthal, Mads Gurtler, Ralph R. Estanboulieh, Dmitry Shvartsman, David K. Gifford, Cole Trapnell** and Doug Melton**<br/>
        <a href = "http://dx.doi.org/10.1016/j.cell.2018.12.003">
          A peninsular structure coordinates asynchronous differentiation with morphogenesis to generate pancreatic islets</a>.<br/>Cell, 2019.<br/><br/>  </li>
      
</ol>
<!-- 
<p> [1] Cole Trapnell, Davide Cacchiarelli, Jonna Grimsby, Prapti Pokharel, Shuqiang Li, Michael Morse, Niall J. Lennon, Kenneth J. Livak, Tarjei S. Mikkelsen, and John L. Rinn. <a href = "http://www.nature.com/nbt/journal/v32/n4/abs/nbt.2859.html"> The dynamics and regulators of cell fate decisions are revealed by pseudotemporal ordering of single cells</a>. Nature Biotechnology, 2014. </p>

<p> [2] Cole Trapnell, Adam Roberts, Loyal Goff, Geo Pertea, Daehwan Kim, David R Kelley, Harold Pimentel, Steven L Salzberg, John L Rinn, and Lior Pachter. <a href = "https://www.ncbi.nlm.nih.gov/pubmed/22383036"> Differential gene and transcript expression analysis of RNA-seq experiments with TopHat and Cufflinks</a>. Nature Protocols, 7(3):562–578, March 2012. </p>

<p> [3] Laurens van der Maaten and Geoffrey Hinton. <a href = "http://www.jmlr.org/papers/volume9/vandermaaten08a/vandermaaten08a.pdf"> Visualizing data using t-SNE</a>. J. Mach. Learn. Res., 9(Nov):2579– 2605, 2008. </p>

<p> [4] Alex Rodriguez. Alessandro Laio. <a href = "http://science.sciencemag.org/content/344/6191/1492"> Clustering by fast search and find of density peaks</a>. Science, 344:1492–1496, 2014. </p>

<p> [5] Hadley Wickham. <a href = "http://www.springer.com/us/book/9780387981413"> ggplot2: Elegant Graphics for Data Analysis</a>. Springer-Verlag New York, 2009. </p>

<p> [6] Simon Anders and Wolfgang Huber. <a href = "https://genomebiology.biomedcentral.com/articles/10.1186/gb-2010-11-10-r106"> Differential expression analysis for sequence count data</a>. Genome Biol., 11(10):R106, 2010. </p>

<p> [7] Qi Mao, Li Wang, Steve Goodison, and Yijun Sun. <a href= "http://dl.acm.org/citation.cfm?id= 2783309"> Dimensionality reduction via graph structure learning</a>. In Proceedings of the 21th ACM SIGKDD International Conference on Knowledge Discovery and Data Mining, pages 765–774. ACM, 2015. </p>

<p> [8] X Qiu, A Hill, J Packer, D Lin, YA Ma, and C Trapnell. <a href= "https://www.ncbi.nlm.nih.gov/pubmed/28114287"> Single-cell mrna quantification and differential analysis with census</a>. Nature methods, 2017. </p>

<p> [9] Rahul Satija, Jeffrey A Farrell, David Gennert, Alexander F Schier, and Aviv Regev. <a href= "https://www.ncbi.nlm.nih.gov/pubmed/25867923"> Spatial reconstruction of single-cell gene expression data</a>. Nat. Biotechnol., 33(5):495–502, May 2015. </p>

<p> [10] Xiaojie Qiu, Qi Mao, Ying Tang, Li Wang, Raghav Chawla, Hannah Pliner, and Cole Trapnell. <a href= "http://www.biorxiv.org/content/early/2017/02/21/110668"> Reversed graph embedding resolves complex single-cell developmental trajectories</a>. 21 February 2017. </p>

<p> [11] Evan Z Macosko, Anindita Basu, Rahul Satija, James Nemesh, Karthik Shekhar, Melissa Goldman, Itay Tirosh, Allison R Bialas, Nolan Kamitaki, Emily M Martersteck, John J Trombetta, David A Weitz, Joshua R Sanes, Alex K Shalek, Aviv Regev, and Steven A McCarroll. <a href= "https://www.ncbi.nlm.nih.gov/pubmed/26000488">Highly parallel genome-wide expression profiling of individual cells using nanoliter droplets</a>. Cell, 161(5):1202–1214, 2015. </p>

<p> [12] Qi Mao, Li Wang, Ivor Tsang, and Yijun Sun. <a href= "http://ieeexplore.ieee.org/document/7769209/?reload=true">Principal graph and structure learning based on reversed graph embedding </a>. IEEE Trans. Pattern Anal. Mach. Intell., 5 December 2016. </p>

<p> [13] Cabili, Moran N. et al. <a href = "https://www.ncbi.nlm.nih.gov/pmc/articles/PMC3185964/">Integrative Annotation of Human Large Intergenic Noncoding RNAs Reveals Global Properties and Specific Subclasses</a>. Genes & Development 25.18 (2011): 1915–1927. PMC. Web. 21 June 2017. </p>
 -->

</div>
</div>
</div>

<br>
<br>
<br>
<br>
<br>
<br>

{% include footer.html %}

</body>

</html>
